# **1. C++概述**

"c++"中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫"c with clsss".通过名称表明，c++是对C的扩展，因此c++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。

> **库是编程模块的集合，可以在程序中调用它们。库对很多常见的编程问题提供了可靠的解决方法，因此可以节省程序员大量的时间和工作量。**

c++语言在c语言的基础上添加了**面向对象编程**和**泛型编程**的支持。c++继承了c语言高效，简洁，快速和可移植的传统。

c++融合了3种不同的编程方式：

- c语言代表的过程性语言.

- c++在c语言基础上添加的类代表的面向对象语言.

- c++模板支持的泛型编程。

**c语言和c++语言的关系:**

c++语言是在C语言的基础上，添加了面向对象、模板等现代程序设计语言的特性而发展起来的。两者无论是从语法规则上，还是从运算符的数量和使用上，都非常相似，所以我们常常将这两门语言统称为“C/C++”。 

C语言和C++并不是对立的竞争关系：

1)C++是C语言的加强，是一种更好的C语言。

2)C++是以C语言为基础的，并且完全兼容C语言的特性。 

c语言和C++语言的学习是可以相互促进。学好C语言，可以为我们将来进一步地学习C++语言打好基础，而C++语言的学习，也会促进我们对于C语言的理解，从而更好地运用C语言。

## 1.1 C++代码运行步骤

在C++中，代码运行通常分为以下几个主要步骤：

### **1.1.1 预处理（Preprocessing）**

- 预处理阶段负责执行编译指令，如`#include`、`#define`、`#if`等宏指令。
- 它是编译的第一阶段，主要由预处理器完成，将源代码文件转换为“预处理过的代码文件”。
- 在这个阶段，预处理器会展开所有宏、包含头文件、删除注释并进行条件编译处理。
- **输出**：生成一个完整的代码文件，包含了所有必要的内容以供编译器分析。

### **1.1.2 编译（Compilation）**

- 编译器将预处理后的代码文件转换为**汇编代码**。
- 这一阶段，编译器会进行词法分析、语法分析、语义分析等。
- **词法分析**：将代码拆分为有意义的记号（Token），如关键字、标识符、操作符等。
- **语法分析**：根据语法规则检查代码结构，并生成抽象语法树（AST）。
- **语义分析**：检查变量类型、函数参数、作用域等，以确保代码逻辑上的正确性。
- **中间代码生成**：编译器可能会将高层代码转为一种中间表示（IR），这便于进行优化。
- **优化**：编译器会进行各种优化，例如消除死代码、循环展开等，以提高执行效率。
- **输出**：生成对应于目标架构的汇编代码。

### **1.1.3 汇编（Assembly）**

- 汇编器将编译生成的汇编代码（通常是低级的近机器语言代码）转换为**目标代码（机器代码）** 。
- 机器代码是由指令和数据组成的二进制编码，可以直接在硬件上运行。
- 在这个阶段，通常会生成二进制文件，如`.o`或`.obj`文件，称为**目标文件**。
- **输出**：一个或多个目标文件，每个文件包含对应模块的机器代码。

### **1.1.4 链接（Linking）**

- 链接器将多个目标文件（包括外部库）合并成一个**可执行文件**。
- 链接器负责将各个模块的符号（如函数地址、变量地址）解析到实际地址，并将这些模块关联在一起。
- 静态链接：将代码直接嵌入可执行文件中，通常适用于静态库。
- 动态链接：将链接推迟到程序运行时，适用于动态库（如`.dll`或`.so`文件）。
- **输出**：生成一个最终的可执行文件。

### **1.1.5 加载（Loading）**

- 由操作系统负责，将可执行文件加载到内存中，为其分配内存空间。
- 操作系统会初始化堆栈和全局变量区域，将入口地址交给处理器，使程序开始执行。
- 如果是动态链接的程序，此时也会加载所需的动态库。

### **1.1.6 运行时（Runtime Execution）**

- 程序在内存中运行，处理器按指令执行代码。
- **程序的生命周期**：包括从开始运行到结束的各个阶段，如初始化、执行主程序、销毁阶段等。
- **内存管理**：在运行时管理堆、栈、全局数据等内存区域，包括动态内存分配、垃圾回收（如果有）等。
- **输入输出**：程序运行时通过标准输入输出设备或网络通信与外界交互。
- **错误处理和异常**：在执行过程中进行错误检查、异常捕获等。

### **1.1.7 总结**

- **预处理** → **编译** → **汇编** → **链接** → **加载** → **运行**

> **c语言与c++代码运行步骤相同吗？**
>
> C语言和C++代码的运行步骤大致相同，但由于C++引入了更多的语言特性，某些阶段可能有所不同。具体区别如下：
>
> 1. **预处理（Preprocessing）** ：C和C++都执行类似的预处理步骤，包括宏替换、头文件包含等。但C++中有一些特有的预处理指令，如`#include <iostream>`，而C语言使用`#include <stdio.h>`。此外，C++的预处理可能还会处理与类、模板相关的代码。
> 2. **编译（Compilation）** ：C和C++在编译阶段的主要区别在于C++需要处理类、对象、模板等复杂特性。C++编译器会对类、成员函数、模板等进行额外的语法和语义检查。
> 3. **汇编（Assembly）** ：C和C++在汇编阶段没有区别，编译器生成的汇编代码大体相同。
> 4. **链接（Linking）** ：C和C++的链接步骤相似，但C++链接时需要处理更复杂的符号，如虚函数表（vtable）、类的构造和析构函数等。此外，C++的链接可能涉及模板实例化，这会影响符号的处理。
> 5. **加载与运行时（Loading & Runtime）** ：C和C++在加载和运行时的处理基本相同，区别主要在于C++程序的对象生命周期管理、构造与析构函数的调用，以及虚拟机和多态性等特性。
>
> 总结来说，C语言和C++的代码运行步骤大体一致，但C++需要处理更多的面向对象特性和语言特性。

## 1.2 C++**内存五大区详解**

> 栈区、 堆区、内存映射段、静态区/数据段、代码段
> 对于五大分区如何分，网络上搜索五花八门都有，其实也不能说是错误的，只不过看待的角度不同，所以不同。我们这个讲的是以操作系统的角度来看待内存的分类。
>
> ![2024-11-14_11-32-27.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/14/2024-11-14_11-32-27.png)

C++的内存可以细分为五大区域，每个区域的功能和特点如下：

### **1.2.1 栈区（Stack Segment）**

**存储内容：**

- 局部变量（包括普通局部变量和函数参数）。
- 函数调用相关信息（返回地址、寄存器状态等）。
- 临时变量和编译器自动管理的变量。

**作用：**

- 用于函数调用时分配局部变量和保存执行上下文。
- 提供快速的内存分配和释放机制。

**位置：**

- 通常位于内存的低地址部分，增长方向是从高地址向低地址。

**特点：**

- **快速**：栈内存的分配和释放速度非常快，通常由编译器直接管理。
- **有序性**：栈以先进后出（LIFO）的方式管理内存。
- **自动性**：在函数调用时分配，在函数返回时释放，开发者无需显式管理。
- **局限性**：栈的大小有限（操作系统决定），深度递归或过多局部变量可能导致栈溢出（Stack Overflow）。

### **1.2.2 堆区（Heap Segment）**

**存储内容：**

- 程序运行时动态分配的内存（例如通过`new`或`malloc`申请的内存）。
- 动态分配的对象或数据结构，如链表、树等。

**作用：**

- 支持运行时动态分配内存，满足程序中不可预知的内存需求。

**位置：**

- 通常位于数据段和栈区之间，内存地址较高，增长方向是从低地址向高地址。

**特点：**

- **灵活性**：程序员可以动态分配和释放内存，适用于复杂数据结构。
- **管理性**：需要显式释放（通过`delete`或`free`），否则可能导致内存泄漏。
- **碎片化**：频繁的分配和释放可能导致堆内存碎片化，降低内存利用率。
- **性能开销**：动态内存分配比栈分配慢，可能引入额外的性能开销。

### **1.2.3 内存映射段（Memory-Mapped Segment）**

**存储内容：**

- 动态链接库（例如`.dll`或`.so`文件）。
- 文件映射到内存的内容（通过`mmap`机制实现）。
- 共享内存区域。

**作用：**

- 实现文件与内存的直接映射，减少磁盘I/O，提高文件操作效率。
- 存储动态加载的代码和共享资源。

**位置：**

- 位于程序的高地址部分，通常在堆区和栈区之外。

**特点：**

- **高效性**：减少文件读取的开销，支持直接通过内存访问文件内容。
- **共享性**：支持多个进程之间的共享内存操作。
- **动态性**：动态链接库加载时按需映射到内存，节省资源。

### **1.2.4 静态区 / 数据段（Static/Data Segment）**

静态区分为两个部分：初始化数据段（Initialized Data Segment）和未初始化数据段（BSS Segment）。

- **初始化数据段（Initialized Data Segment）** ：
  - **存储内容**：存储程序中已初始化的全局变量、静态变量、常量等。这些变量在程序启动时会被赋予一个初值。
  - **作用**：用于存储程序的全局变量和静态变量，这些变量在整个程序的生命周期内存在。
  - **位置**：位于静态区的开始部分，紧接着代码段。
  - **特点**：这部分内存是由操作系统分配并初始化的，变量的初值在编译时确定。
- **未初始化数据段（BSS Segment）** ：
  - **存储内容**：存储未初始化的全局变量和静态变量。这些变量在程序启动时会被自动初始化为零（或空指针）。
  - **作用**：存储程序中未显式初始化的全局和静态变量。
  - **位置**：位于初始化数据段之后，但在堆和栈之前。
  - **特点**：这部分内存不需要显式存储初值，因此不会占用磁盘空间，只在程序运行时分配内存。
- **特点总结**：
  - **内存空间固定**：静态区内存大小在程序启动时就已经确定，且在程序的整个生命周期内都存在。
  - **生命周期长**：静态区中的变量在程序的整个生命周期内有效，从程序启动到退出。

### **1.2.5 代码段（Code Segment / Text Segment）**

**存储内容：**

- 程序的可执行代码（编译生成的机器指令）。
- 常量字符串（某些情况下放入代码段，也可能划入常量区）。

**作用：**

- 提供程序运行的指令，存储可执行逻辑。

**位置：**

- 位于内存的最低地址部分。

**特点：**

- **只读性**：通常是只读的，防止代码被修改（某些情况下可以设置为可写，主要用于调试）。
- **共享性**：同一程序的多个进程实例可以共享代码段，减少内存使用。
- **静态性**：存储的内容在程序运行过程中不会改变。

------

### **1.2.6 总结表格**

| **内存区域**   | **存储内容**                   | **作用**               | **位置**         | **特点**                             |
| -------------- | ------------------------------ | ---------------------- | ---------------- | ------------------------------------ |
| 栈区（Stack）  | 局部变量、函数调用信息         | 管理函数调用和局部变量 | 内存低地址部分   | 自动管理、高效分配、栈溢出风险       |
| 堆区（Heap）   | 动态分配的对象                 | 动态分配内存           | 数据段和栈区之间 | 灵活管理、易碎片化、需手动释放       |
| 内存映射段     | 动态链接库、共享内存、文件映射 | 文件映射、动态加载资源 | 堆区和栈区之外   | 高效文件操作、支持进程间共享         |
| 静态区/数据段  | 全局变量、静态变量、常量数据   | 持久存储静态数据       | 代码段和堆区之间 | 初始化数据和未初始化数据分开管理     |
| 代码段（Code） | 可执行指令、部分常量           | 提供程序的执行逻辑     | 内存低地址部分   | 通常只读，可共享，不会随程序运行改变 |

通过理解这些内存区域及其特点，开发者可以更高效地利用内存，避免常见错误如内存泄漏和栈溢出，同时编写出性能优化的程序。

### 1.2.7 示例

![2024-11-14_11-33-27.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/14/2024-11-14_11-33-27.png)

> **细节：**
>
> - `void Test() { ... }`: 函数`Test`的代码会存储在**代码段**中，包括所有的函数代码及指令。
> - int num1[10] = { 1, 2, 3, 4 };数组的本体 { 1, 2, 3, 4 }存储在**栈区**中。

### 1.2.8 **存储位置补充细节**

**数组存储位置详解：**

在 C++ 中，**数组的存储位置**（即数组元素在内存中具体的分配位置）会根据数组的**声明方式**有所不同，主要有以下三种情况：

1. **栈区**（Stack）：
   - 如果数组是**局部变量**（即在函数内部声明，不使用 `static` 修饰），数组内容会被存储在栈区。栈区内存由操作系统自动管理，函数结束时栈上的局部数组会被自动释放。
   - 例如：`int arr[10];` 在函数内部定义的 `arr` 就会被分配在栈区。
2. **数据区**（Data Segment）：
   - **全局数组**或用 `static` 修饰的**静态数组**会存储在数据区。这种数组的生命周期与程序相同，直到程序结束才会释放。
   - 数据区包括**初始化数据段**和**未初始化数据段（BSS）** 。如果数组有初始值，数组会存储在初始化数据段；如果没有初始值，则存储在 BSS 段。
   - 例如：在函数外部声明的 `int arr[10];` 或在函数内用 `static` 修饰的 `static int arr[10];` 数组就会存储在数据区。
3. **堆区**（Heap）：
   - 如果数组是**动态分配**的（使用 `new` 或 `malloc`），则会被分配在堆区。堆区内存需要手动释放，否则可能会导致内存泄漏。
   - 例如：`int* arr = new int[10];` 分配的数组会被放到堆区，程序员需要在不再使用时手动释放它（如 `delete[] arr;`）。

总结来说，这句话表示数组在内存中的位置取决于声明方式，不同存储位置会影响内存管理方式和生命周期。

**指针的存储位置：**

在C++中，指针变量存放在内存的栈区。栈区是一块连续的内存空间，用于存储局部变量和函数调用时的参数。当我们声明一个指针变量时，它会被分配在栈区，并且占用固定大小的内存空间。

指针变量存放在栈区中，而指针所指向的对象或者内存地址则可以位于栈区、堆区或者全局/静态存储区。当我们使用指针来引用一个对象时，指针会保存该对象的内存地址。

需要注意的是，指针变量本身的值（即存放的地址）是存放在栈区的，而指针所指向的对象或者内存地址所对应的数据则可能位于其他不同的内存区域。

**类实例存储位置：**

在 C++ 中，类实例的存储位置取决于实例的声明方式：

1. **栈区（Stack）** ：
   - **局部对象**：如果类的实例是在函数内创建的局部对象（如 `MyClass obj;`），则该实例会存储在栈区。它的生命周期与函数调用的作用域一致，函数返回后会自动销毁。
2. **堆区（Heap）** ：
   - **动态分配的对象**：如果类实例通过 `new` 运算符动态分配内存（如 `MyClass* obj = new MyClass();`），则该实例存储在堆区。需要手动调用 `delete` 来释放内存。
3. **数据段（Data Segment）** ：
   - **静态或全局对象**：如果类的实例是静态或全局对象（如 `static MyClass obj;` 或 `MyClass obj;` 在函数外部声明），则实例会存储在数据段。其生命周期与程序运行期间一致。

**总结：**

- 局部类实例存储在 **栈区**。
- 动态分配的类实例存储在 **堆区**。
- 静态或全局类实例存储在 **数据段**。

### 1.2.9 基本数据类型和对象数据类型有什么，以及它们的存储位置

在 C++ 中，**基本数据类型**和**对象数据类型**具有不同的内存分配和操作特性。以下是它们的主要区别：

**1. 基本数据类型**

- **定义**：基本数据类型是编译器预定义的数据类型，包括整数、浮点数、字符等。
- **种类**：
  - **整数类型**：`int`、`short`、`long`、`long long`、`unsigned` 类型等。
  - **浮点数类型**：`float`、`double`、`long double`。
  - **字符类型**：`char`，以及 `wchar_t`、`char16_t`、`char32_t` 等扩展字符类型。
  - **布尔类型**：`bool`。
- **存储方式**：根据变量定义的位置可以存储在**栈区**、**数据区**等。基本类型的内存分配和管理通常由编译器自动完成。
- **内存大小**：基本类型的大小通常是固定的（例如 `int` 通常为 4 字节），但可以受编译器和平台影响。

**2. 对象数据类型**

- **定义**：对象数据类型指的是用户定义的类或结构体（`struct`）等复杂数据类型。
- **种类**：
  - **类类型**：用户定义的类或结构体实例。
  - **STL 容器**：如 `std::string`、`std::vector`、`std::map` 等。
- **存储方式**：
  - **栈区**：当对象以局部变量的形式在函数中定义时，存储在栈区。
  - **堆区**：当对象使用 `new` 关键字动态分配时，存储在堆区。
  - **数据区**：如果对象是全局或静态变量，存储在数据区。
- **内存管理**：对象的数据成员可以是基本数据类型或其他对象，内存大小取决于对象的成员数量和类型。对象生命周期的管理则依赖于**构造函数**和**析构函数**。
- **特性**：对象可以包含成员函数、继承、虚函数、封装等特性，这使得对象的存储和管理复杂度较高。

**总结对比**

| 特性     | 基本数据类型                 | 对象数据类型                                    |
| -------- | ---------------------------- | ----------------------------------------------- |
| 存储区域 | 栈区、数据区                 | 栈区、堆区、数据区                              |
| 内存管理 | 编译器自动管理               | 需用户管理（堆区）、构造/析构函数控制（非堆区） |
| 大小     | 固定大小，受编译器和平台影响 | 可变大小，视成员变量和类型而定                  |
| 特性     | 没有继承、封装、方法等       | 支持封装、继承、多态等面向对象特性              |

基本数据类型适合简单的数据存储和运算，而对象数据类型更适合复杂的场景和逻辑封装。

> 补充细节：
>
> - 字符串分为char数组形式的字符串和其他形式的如STL 容器中 `std::string` 形式的字符串。
> - 不管是字符串还是数组，它们都可能存储在栈或堆中，这取决于是否使用了new或malloc。

## **1.3 c++起源**

与c语言一样，c++也是在贝尔实验室诞生的，Bjarne Stroustrup(本贾尼·斯特劳斯特卢普)在20世纪80年代在这里开发了这种语言。

![2024-11-11_15-11-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-11-09.png.png)

**(C++之父-**本贾尼·斯特劳斯特卢普**)**

Stroustrup关心的是让c++更有用，而不是实施特定的编程原理或风格。在确定语言特性方面，真正的编程比纯粹的原理更重要。Stroustrup之所以在c的基础上创建c++,是因为c语言简洁、适合系统编程、使用广泛且与UNIX操作系统联系紧密。

用他自己的话来说，"C++主要是为了我的朋友和我不必再使用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，让每个程序员更加快乐"。

## **1.4 可移植性和标准**

假设为运行windows 2000的老式奔腾pc编写了一个很好用的c++程序，而管理员决定使用不同操作系统(比如说Mac OS 或 Linux)和处理器的计算机替换它。该程序是否可在新平台运行呢？当然，但是必须使用为新平台设计的c++编译器重新编译。但是是否需要修改写好的代码？如果不需要修改代码的情况下，重新编译程序后，程序依然运行良好，该程序是可移植的。

程序是否可移植性有两个问题需要解决。第一是硬件，针对特定硬件编程的程序是不可移植的。第二，语言的实现，windows xp c++ 和 Redhat Linux 或 Mac OS X对c++的实现不一定相同。虽然我们希望c++版本与其他版本兼容，但是如果没有一个公开的标准，很难做到。因此，美国国家标准局(American National Standards Institute,ANSI)在1990年设立一个委员会专门负责制定c++标准(ANSI制定了c语言的标准)。国际标准化组织(International Organization for Standardization，ISO)很快通过自己的委员会加入到这个行列，创建了联合组织ANSI/ISO,制定c++标准。

经过多年的努力，制定出了一个国际标准ISO/IEC 14882:1998 ，并于1998年获得了ISO、IEC(International Electrotechnical Committee,国际电工技术委员会)和ANSI的批准。这个标准就是我们经常所说的c++98。它不仅描述了已有的c++特性，还对语言进行了扩展，添加了异常、运行阶段类型识别(RTTI)、模板和标准模板库(STL).

2003年，发布了c++标准第二版(IOS/IEC 14882:2003),这一版本对第一版修订了一些错误，但并没有改变语言特性，因此c++98表示c++98/c++2003.

c++不断发展。IOS标准委员会于2011年8月批准了新标准ISO/IEC 14882:2011,该标准被称为c++11,与c++98一样c++11也新增了许多特性。

ISO c++标准还吸收了ANSI c语言标准，c++尽量做到是c的超集。意味着在理想情况下，任何有效的c程序都应该是有效的c++程序。

ANSI不仅定义了c语言，还 定义了一个ANSI c必须实现的标准c库。c++也在使用这个库，另外ANSI/ISO c++标准还提供了一个c++标准类库。、

## **1.5 为什么C++会成功**

c++最初的目的是将c语言转变为OOP（面向对象程序设计）语言，但是c++后来并没有这么做，而是立足于程序的实际。因为在c语言方面大量投入的程序员使其完全丢掉c语言那种编程的思考方式，转而去接受一种新的语言，新的思维，那么将会导致这些程序员中大部分人在短时间内可能毫无成果，使其生产率降低。但是如果让这些c程序员在已有知识的基础上，再去学习c++语言，理解运用OOP，那么也只是在其已有思维的基础上进行扩展而已，这样可以保持其更好的生产率。

简而言之，强迫程序员放弃c语言和c语言的思考方式，而去转到OOP上是需要代价的，但是从c语言转到c++所花费的代价就会小很多。所以也可以理解为c++的出现并不是去替代c,而是对c的扩展，所以在c++中既可以使用c++新特性，并且可以使用c的过程式思维来编写程序。

对于传统的结构化语言，我们向来没有太多的疑惑，函数调用那么自然而明显，只是从程序的某一个地点调到另一个地点去执行。但是对于面向对象(OO)语言，我们疑惑就会很多。其原因就是c++编译器为我们程序员做了太多隐藏的工作：构造函数，析构函数、虚函数、继承、多态....有时候它为我们合成出一些额外的函数,有时候它又偷偷在我们写的函数里，放进更多的操作。有时候也会给我们的对象里放进一些奇妙的东西，使得我们sizeof的时候结果可我们预期不一样。

# **2. C++初识**

## **2.1 简单的c++程序**

### **2.1.1 c++ hello world**

请打开一下示例代码：

```cpp
#include<iostream>
using namespace std;

int main(){	
	cout << "hello world" << endl;
	return EXIT_SUCCESS;
}
```

**分析:**

- \#include<iostream>; 预编译指令，引入头文件iostream.
- using namespace std; 使用标准命名空间
- cout << "hello world"<< endl; 和printf功能一样，输出字符串"hello wrold"

**问题1**：c++头文件为什么没有.h？

在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath.

由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI/IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。

| 头文件类型  | 约定               | 示例       | 说明                                        |
| ----------- | ------------------ | ---------- | ------------------------------------------- |
| c++旧式风格 | 以.h结尾           | iostream.h | c++程序可用                                 |
| c旧式风格   | 以.h结尾           | math.h     | c/c++程序可用                               |
| c++新式风格 | 无扩展名           | iostream   | c++程序可用，使用namespace std              |
| 转换后的c   | 加上前缀c,无扩展名 | cmath      | c++程序可用，可使用非c特性，如namespace std |

**问题2**：using namespace std 是什么?

namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。

> 这段话主要解释了 C++ 中的 **命名空间（namespace）** 的概念。为了便于理解，可以将它拆解成几个关键点：
>
> **1. 命名空间的作用**
>
> - 命名空间是一种 **作用域机制**，用于解决不同代码库中的 **命名冲突问题**。在大型项目中，不同模块、库可能会有相同名称的函数、类或变量，如果不加以区分，会导致冲突。通过将这些代码包裹在命名空间中，可以让同名的标识符在各自的命名空间内独立存在，避免冲突。
>
> **2. 命名空间的定义**
>
> 命名空间是使用 `namespace` 关键字来定义的。例如，标准库中的命名空间称为 `std`，包含了 C++ 标准库的大量组件（如 `cout`, `cin`, `string` 等）。定义命名空间的语法如下：
>
> ```cpp
> namespace MyNamespace {
>     int value = 10;
>     void myFunction() {
>         // 函数体
>     }
> }
> ```
>
> - 这里，`MyNamespace` 是命名空间的名字，所有在其内部定义的实体（如变量 `value` 和函数 `myFunction`）都属于这个命名空间。
>
> **3. 命名空间的可见性**
>
> - 命名空间的名字就像是一个“标签”，表示一个逻辑上的分组。要使用命名空间中的内容，通常要加上命名空间的前缀。例如：
>
>   ```cpp
>   MyNamespace::myFunction();  // 使用MyNamespace中的myFunction函数
>   ```
>
> - 这样可以明确地指定我们调用的 `myFunction` 是 `MyNamespace` 里的，而不是其他命名空间中的同名函数。
>
> **4.** `using namespace` 简化引用
>
> - `using namespace std;` 这种语句可以让程序在当前作用域内直接访问 `std` 命名空间中的内容，而不需要每次都写 `std::` 前缀。这简化了代码书写，但也可能引入命名冲突，所以在大型项目中一般仅在 `.cpp` 文件中使用，而避免在头文件中使用。
>
> **例子总结**
>
> 假设我们有两个命名空间 `A` 和 `B`，它们内部都有一个名为 `print` 的函数：
>
> ```cpp
> namespace A {
>     void print() {
>         cout << "This is namespace A" << endl;
>     }
> }
> 
> namespace B {
>     void print() {
>         cout << "This is namespace B" << endl;
>     }
> }
> ```
>
> 在主函数中，我们可以这样选择调用不同的 `print`：
>
> ```cpp
> A::print();  // 调用 A 命名空间的 print 函数
> B::print();  // 调用 B 命名空间的 print 函数
> ```
>
> **总结**
>
> 命名空间帮助将逻辑相关的代码分组，避免命名冲突，通过 `namespace` 关键字定义，并可以使用 `using namespace` 来简化代码书写。

**问题3**：cout 、endl 是什么？

cout是c++中的标准输出流，endl是输出换行并刷新缓冲区。

**问题4**：如果不调用 endl会怎么样？

1. **输出显示延迟**：程序在输出内容后，如果没有调用 `endl` 或其他刷新操作，输出可能会暂时存在缓冲区内，直到缓冲区满或程序结束才显示出来。这在一些实时程序中可能导致内容不能立即输出。
2. **性能提升**：在频繁输出场景下，`endl`的缓冲刷新操作可能导致性能瓶颈。使用 `"\n"` 可以减少不必要的刷新，提高程序运行效率。
3. **输出流管理**：对于需要立即显示的内容，`endl`更适合，因为它确保输出流实时刷新。

### **2.1.2 面向过程**

面向过程是一种以过程为中心的编程思想。

通过分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

面向过程编程思想的核心：功能分解，自顶向下，逐层细化（程序=数据结构+算法）。

面向过程编程语言存在的主要缺点是不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。

### **2.1.3 面向对象**

**面向对象编程**（Object-Oriented Programming）简称 OOP 技术，是开发计算机应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。

在面向对象中，算法与数据结构被看做是一个整体，称作对象，现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述，所以可以用下面的等式来定义对象和程序：

- 对象 = 算法 + 数据结构
- 程序 = 对象 + 对象 + ……

从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体。

面向对象编程思想的核心：应对变化，提高复用。

### **2.1.4 面向对象三大特性**

- 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。

- 继承

继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。

继承的作用：避免公用代码的重复开发，减少代码和数据冗余。

- 多态

多态性可以简单地概括为"一个接口，多种方法"，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

# **3. C++对C的扩展**

## **3.1 ::作用域运算符**

通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。

```cpp
//全局变量
int a = 10;
void test(){
	//局部变量
	int a = 20;
	//全局a被隐藏
	cout << "a:" << a << endl;
}
```

程序的输出结果是a:20。在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。

作用域运算符可以用来解决局部变量与全局变量的重名问题 

```cpp
//全局变量
int a = 10;
//1. 局部变量和全局变量同名
void test(){
	int a = 20;
	//打印局部变量a
	cout << "局部变量a:" << a << endl;
	//打印全局变量a
	cout << "全局变量a:" << ::a << endl;
}
```

这个例子可以看出，作用域运算符可以用来解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。

## **3.2 名字控制**

创建名字是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量名字。c++允许我们对名字的产生和名字的可见性进行控制。

我们之前在学习c语言可以通过static关键字来使得名字只得在本编译单元内可见，在c++中我们将通过命名空间来控制对名字的访问。

### **3.2.1 C++命名空间(namespace)**

在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。

### **3.2.2命名空间使用语法**

- 创建一个命名空间:

```cpp
namespace A{
	int a = 10;
}
namespace B{
	int a = 20;
}
void test(){
	cout << "A::a : " << A::a << endl;
	cout << "B::a : " << B::a << endl;
}
```

- 命名空间只能全局范围内定义（**以下错误写法**）

```cpp
void test(){
	namespace A{
		int a = 10;
	}
	namespace B{
		int a = 20;
	}
	cout << "A::a : " << A::a << endl;
	cout << "B::a : " << B::a << endl;
}
```

- 命名空间可嵌套命名空间

```cpp
namespace A{
	int a = 10;
	namespace B{
		int a = 20;
	}
}
void test(){
	cout << "A::a : " << A::a << endl;
	cout << "A::B::a : " << A::B::a << endl;
}
```

- 命名空间是开放的，即可以随时把新的成员加入已有的命名空间中

```cpp
namespace A{
	int a = 10;
}

namespace A{
	void func(){
		cout << "hello namespace!" << endl;
	}
}

void test(){
	cout << "A::a : " << A::a << endl;
	A::func();
}
```

- 声明和实现可分离

```cpp
#pragma once

namespace MySpace{
	void func1();
	void func2(int param);
}

void MySpace::func1(){
	cout << "MySpace::func1" << endl;
}
void MySpace::func2(int param){
	cout << "MySpace::func2 : " << param << endl;
}
```

- 无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接

```cpp
namespace{
	
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}
void test(){
	cout << "a : " << a << endl;
	func();
}
```

- 命名空间别名

```cpp
namespace veryLongName{
	
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}

void test(){
	namespace shortName = veryLongName;
	cout << "veryLongName::a : " << shortName::a << endl;
	veryLongName::func();
	shortName::func();
}
```

### **3.2.3 using声明**

using声明可使得指定的标识符可用。

```cpp
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcA" << endl; }
}

void test(){
	//1. 通过命名空间域运算符
	cout << A::paramA << endl;
	A::funcA();
	//2. using声明
	using A::paramA;
	using A::funcA;
	cout << paramA << endl;
	//cout << paramB << endl; //不可直接访问
	funcA();
	//3. 同名冲突
	//int paramA = 20; //相同作用域注意同名冲突
}
```

using声明碰到函数重载

```cpp
namespace A{
	void func(){}
	void func(int x){}
	int  func(int x,int y){}
}
void test(){
	using A::func;
	func();
	func(10);
	func(10, 20);
}
```

如果命名空间包含一组用相同名字重载的函数，using声明一个就声明了这个重载函数的所有集合。

### **3.2.4 using编译指令**

using编译指令使整个命名空间标识符可用.

```cpp
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test01(){
	using namespace A;
	cout << paramA << endl;
	cout << paramB << endl;
	funcA();
	funcB();

	//不会产生二义性
	int paramA = 30;
	cout << paramA << endl;
}

namespace B{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test02(){
	using namespace A;
	using namespace B;
	//二义性产生，不知道调用A还是B的paramA
	//cout << paramA << endl;
}
```

> **注意：使用using声明或using编译指令会增加命名冲突的可能性。也就是说，如果有名称空间，并在代码中使用作用域解析运算符，则不会出现二义性。**

### **3.2.5 命名空间使用**

我们刚讲的一些东西一开始会觉得难一些，这些东西以后还是挺常用，只要理解了它们的工作机理，使用它们非常简单。

需要记住的关键问题是当引入一个全局的using编译指令时，就为该文件打开了该命名空间，它不会影响任何其他的文件，所以可以在每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多的using指令而产生的命名冲突，就要对该文件做个简单的改变，通过明确的限定或者using声明来消除名字冲突，这样不需要修改其他的实现文件。

## **3.3 全局变量检测增强**

c语言代码：

```c
//int a = 10; //赋值，当做定义
int a; //没有赋值，当做声明

int main(){
	printf("a:%d\n",a);
	return EXIT_SUCCESS;
}
```

此代码在c++下编译失败,在c下编译通过.

> C允许未初始化的局部变量使用，但值不确定；而C++不允许这种情况，要求变量在使用前进行初始化。

## **3.4 C++中所有的变量和函数都必须有类型**

c语言代码：

```c
//i没有写类型，可以是任意类型
int fun1(i){
	printf("%d\n", i);
	return 0;
}
//i没有写类型，可以是任意类型
int fun2(i){
	printf("%s\n", i);
	return 0;
}
//没有写参数，代表可以传任何类型的实参
int fun3(){ 
	printf("fun33333333333333333\n");
	return 0;
}

//C语言，如果函数没有参数，建议写void，代表没有参数
int fun4(void){
	printf("fun4444444444444\n");
	return 0;
}

g(){
	return 10;
}

int main(){

	fun1(10);
	fun2("abc");
	fun3(1, 2, "abc");
	printf("g = %d\n", g());

	return 0;
}
```

以上c代码c编译器编译可通过，c++编译器无法编译通过。

> 在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。
>
> 在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。

## **3.5 更严格的类型转换**

在C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。

c语言代码：

```c
typedef enum COLOR{ GREEN, RED, YELLOW } color;
int main(){

	color mycolor = GREEN;
	mycolor = 10;
	printf("mycolor:%d\n", mycolor);
	char* p = malloc(10);
	return EXIT_SUCCESS;
}
```

> **代码分析**
>
> ```c
> typedef enum COLOR { GREEN, RED, YELLOW } color;
> ```
>
> 1. **定义枚举类型和别名**
>    - 定义了一个 `enum COLOR` 枚举类型，包含三个枚举值：`GREEN`、`RED` 和 `YELLOW`，分别对应整数 `0`、`1` 和 `2`。
>    - 使用 `typedef` 为 `enum COLOR` 定义别名 `color`，这样可以直接用 `color` 作为枚举类型的简化名称。
>    - `typedef` 不会为 `color` 添加任何类型安全检查，实际上 `color` 仍然是 `int` 类型的别名。
>
> ```c
> int main() {
> ```
>
> 1. **主函数**
>    - 进入 `main()` 函数，程序的执行从这里开始。
>
> ```c
> color mycolor = GREEN;
> ```
>
> 1. **声明并初始化枚举变量**
>    - 使用 `color` 定义变量 `mycolor`，并将它初始化为枚举值 `GREEN`。
>    - 由于 `GREEN` 的枚举值为 `0`，此时 `mycolor` 的值为 `0`。
>
> ```c
> mycolor = 10;
> ```
>
> 1. **赋值操作**
>    - `mycolor` 被赋值为 `10`，尽管这个值不在 `COLOR` 枚举的定义范围内。
>    - 在 C 语言中，枚举类型只是整数的一种标签，没有强制范围限制，因此这种赋值不会报错。
>    - 然而，由于 `mycolor` 不再是有效的枚举值，此时程序的逻辑可能变得不清晰或容易出错。
>
> ```c
> printf("mycolor:%d\n", mycolor);
> ```
>
> 1. **输出枚举变量的值**
>    - 使用 `printf` 函数输出 `mycolor` 的值，预期输出为 `mycolor:10`，因为 `mycolor` 的当前值是 `10`。
>
> ```c
> char* p = malloc(10);
> ```
>
> 1. **内存分配**
>    - `malloc(10)` 分配了 10 字节的内存，并返回指向该内存块的指针，将其赋值给 `p`。
>    - 这里没有调用 `free(p);` 释放分配的内存，导致内存泄漏。
>    - 虽然这段代码很短且在 `main()` 函数结束时程序会自动释放内存，但在更大的程序中，应始终释放 `malloc` 分配的内存。
>
> ```c
> return EXIT_SUCCESS;
> ```
>
> 1. **返回值**
>    - 使用 `EXIT_SUCCESS` 表示程序成功退出，`EXIT_SUCCESS` 通常等于 `0`。

以上c代码c编译器编译可通过，c++编译器无法编译通过。

> - **C 语言**允许枚举类型隐式转换为整数类型，因此可以直接赋值 `mycolor = 10;`。
> - **C++ 语言**则强制要求枚举类型保持类型安全，不允许隐式转换为整数，因此需要显式转换，如 `static_cast<color>(10)`，才能通过编译。

## **3.6 struct类型加强**

- c中定义结构体变量需要加上struct关键字，c++不需要。
- c中的结构体只能定义成员变量，不能定义成员函数。c++即可以定义成员变量，也可以定义成员函数。

```cpp
//1. 结构体中即可以定义成员变量，也可以定义成员函数
struct Student{
	string mName;
	int mAge;
	void setName(string name){ mName = name; }
	void setAge(int age){ mAge = age; }
	void showStudent(){
		cout << "Name:" << mName << " Age:" << mAge << endl;
	}
};

//2. c++中定义结构体变量不需要加struct关键字
void test01(){
	Student student;
	student.setName("John");
	student.setAge(20);
	student.showStudent();
}
```

## **3.7 "新增"bool类型关键字**

标准c++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态。这三个名字都是关键字。

- bool类型只有两个值，true(1值)，false(0值)
- bool类型占1个字节大小
- 给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)

```cpp
	void test()
{	cout << sizeof(false) << endl; //为1，//bool类型占一个字节大小
	bool flag = true; // c语言中没有这种类型
	flag = 100; //给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)
}
```

> **[c语言中的bool类型]**
>
> c语言中也有bool类型，在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件stdbool.h,就可以使用和c++一样的bool类型。

## **3.8 三目运算符功能增强**

- c语言三目运算表达式返回值为数据值，为右值，不能赋值。

```c
int a = 10;
	int b = 20;
	printf("ret:%d\n", a > b ? a : b);
	//思考一个问题，(a > b ? a : b) 三目运算表达式返回的是什么？
	
	//(a > b ? a : b) = 100;//返回的是右值，错误！不能将右值赋值，即它仅仅是一个临时值，不能直接进行赋值操作。
```

- c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。

```cpp
int a = 10;
	int b = 20;
	printf("ret:%d\n", a > b ? a : b);
	//思考一个问题，(a > b ? a : b) 三目运算表达式返回的是什么？
	cout << "b:" << b << endl;
	//返回的是左值，变量的引用
	(a > b ? a : b) = 100;//返回的是左值，变量的引用，在 C++ 中是合法的
	cout << "b:" << b << endl;
```

> **[左值和右值概念]**
>
> 在c++中可以放在赋值操作符左边的是左值，可以放到赋值操作符右面的是右值。
>
> 有些变量即可以当左值，也可以当右值。
>
> 左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。
>
> 右值为Rvalue，R代表Read,就是可以知道它的值。
>
> 比如:int temp = 10; temp在内存中有地址，10没有，但是可以Read到它的值。

## **3.9 C/C++中的const**

### **3.9.1 const概述**

const单词字面意思为常数，不变的。它是c/c++中的一个关键字，是一个限定符，它用来限定一个变量不允许改变，它将一个对象转换成一个常量。

```cpp
const int a = 10;
a = 100; //编译错误,const是一个常量，不可修改
```

### **3.9.2 C/C++中const的区别**

#### **3.9.2.1 C中的const**

常量的引进是在c++早期版本中，当时标准C规范正在制定。那时，尽管C委员会决定在C中引入const,但是，他们c中的const理解为"一个不能改变的普通变量"，也就是认为const应该是一个只读变量，既然是变量那么就会给const分配内存，并且在c中const是一个全局只读变量，c语言中const修饰的只读变量是外部连接的。

如果这么写:

```cpp
const int arrSize = 10;
int arr[arrSize];
```

看似是一件合理的编码，但是这将得出一个错误。 因为arrSize占用某块内存，所以C编译器不知道它在编译时的值是多少？

#### **3.9.2.2 C++中的const**

**1.** `const` 内存分配的差异（C++ vs C）

- **在C++中**，编译器可以决定是否为`const` 常量分配内存空间，这取决于使用方式。如果一个`const`常量仅用于替代一个值（类似 `#define`），编译器可能不会为其创建存储空间，而是会直接将该值“折叠”进代码中（称为常量折叠或编译期内联）。这样做可以提高代码的执行效率。
- **在C语言中**，`const`常量始终会分配内存空间。即使该常量仅在编译时使用，它也会在内存中保留一块区域来存储该值。

**2.** `const` 常量的存储空间分配条件（C++中）

在C++中，如果以下情况之一发生，编译器会为`const` 常量分配内存空间：

- **取常量的地址**：如果代码中获取了 `const` 常量的地址（例如通过 `&` 操作符），则该常量必须存在于内存中，编译器会为其分配空间。
- **定义为** `extern` ：如果一个 `const` 常量被声明为 `extern`（外部连接），意味着它可以在多个文件间共享，这也会导致编译器为该常量分配内存空间。

**3.** `const` 常量的链接性（Linkage）

- **内部连接（Internal Linkage）** ：在C++中，出现在所有函数之外的 `const` 常量默认为内部连接（`internal linkage`），即该常量只能在定义它的文件中使用，对其他文件不可见。
- **外部连接（External Linkage）** ：C++中其他标识符通常默认为外部连接（`external linkage`），可以跨文件访问。但如果希望 `const` 常量具有外部连接性（比如跨文件访问），需要将其显式声明为 `extern`，并在某个源文件中定义该常量。

#### **3.8.2.3 C/C++中const异同总结**

- c语言全局const会被存储到只读数据段。c++中全局const当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。两个都受到了只读数据段的保护，不可修改。

```cpp
 const int constA = 10;
      int main(){
           int* p = (int*)&constA;
           *p = 200;
     }
```

> 以上代码在c/c++中编译通过，在运行期，修改constA的值时，发生写入错误。原因是修改只读数据段的数据。

- c语言中局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。

```c
const int constA = 10;
	int* p = (int*)&constA;
	*p = 300;
	printf("constA:%d\n",constA);
	printf("*p:%d\n", *p);
```

> 运行结果：
>
> ![2024-11-11_15-12-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-12-09.png.png) c语言中，通过指针间接赋值修改了constA的值。

c++中对于局部的const变量要区别对待：

1. 对于基础数据类型，也就是const int a = 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存。

```cpp
const int constA = 10;
	int* p = (int*)&constA;
	*p = 300;
	cout << "constA:" << constA << endl;
	cout << "*p:" << *p << endl;
```

> 运行结果：
>
> ![2024-11-11_15-13-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-13-09.png.png)输出中 `constA` 的值还是 **10**，而 `*p` 的值是 **300**。这是因为：
>
> - **编译器优化**：C++编译器会将 `constA` 的值直接替换为字面值 10，因此 `cout << constA;` 会输出 `10`。
> - **内存实际值**：指针 `p` 修改了 `constA` 的内存内容，使得 `*p` 变为 `300`。

1. 对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存。

```cpp
int b = 10;
const int constA = b;
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;
```

> 运行结果：
>
> ![2024-11-11_15-14-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-14-09.png.png)
>
> constA 分配了内存，所以我们可以修改constA内存中的值。

1. 对于自定数据类型，比如类对象，那么也会分配内存。

```cpp
const Person person; //未初始化age
	//person.age = 50; //不可修改
	Person* pPerson = (Person*)&person;
	//指针间接修改
	pPerson->age = 100;
	cout << "pPerson->age:" << pPerson->age << endl;
	pPerson->age = 200;
	cout << "pPerson->age:" << pPerson->age << endl;
```

> 运行结果：
>
> ![2024-11-11_15-15-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-15-09.png.png)为person分配了内存，所以我们可以通过指针的间接赋值修改person对象。

- c中const默认为外部连接，c++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10;

> **在C++中声明具有外部连接的**`const`常量
>
> 如果想要在C++中创建一个**全局共享**的`const`常量，必须显式将其定义为具有**外部连接**，这可以通过`extern`关键字实现。例如：
>
> ```cpp
> // file1.cpp
> extern const int a = 10;  // 定义一个具有外部连接的常量
> 
> // file2.cpp
> extern const int a;       // 声明与file1.cpp中的常量 a 相同的外部常量
> ```
>
> 这样，`a`的定义只有在一个文件中出现，而在其他文件中则是通过`extern`关键字进行声明，使得在多个文件间可以共享同一个`const`常量。

const 关键字起初在 C++ 中出现，后来被引入标准 C，但两者对 const 的处理方式不同。在 C 中，编译器对 const 常量的处理类似于变量，只是标记为"不可修改"。在 C++ 中，const 常量具有内部连接，因此在不同文件中定义同名的 const 不会导致链接错误。而在 C 中，const 常量默认具有外部连接，因此在多个文件中定义同名的 const 可能会引发链接错误。总的来说，C++ 对 const 常量的处理更合理。

### **3.9.3 尽量以const替换#define**

在旧版本C中，如果想建立一个常量，必须使用预处理器"

\#define MAX 1024;

我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经被替换为了1024，于是MAX并没有将其加入到符号表中。但我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX.如果MAX被定义在一个不是你写的头文件中，你可能并不知道1024代表什么，也许解决这个问题要花费很长时间。

解决办法就是用一个常量替换上面的宏。

const int max= 1024;

const和#define区别总结:

- const有类型，可进行编译器类型安全检查。#define无类型，不可进行类型检查.
- const有作用域，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。

## **3.10 引用(reference)**

### **3.10.1 引用基本用法**

**引用是c++对c的重要扩充。**在c/c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是c++的发明。

- 变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)
- 程序中通过变量来申请并命名内存空间
- 通过变量的名字可以使用存储空间

对一段连续的内存空间只能取一个别名吗？

c++中新增了引用的概念，引用可以作为一个已定义变量的别名。

基本语法:`Type& ref = val;`

注意事项：

- &在此不是求地址运算，而是起标识作用。
- 类型标识符是指目标变量的类型

- 必须在声明引用变量时进行初始化。
- 引用初始化之后不能改变。
- 不能有NULL引用。必须确保引用是和一块合法的存储单元关联。
- **可以建立对数组的引用。**

```cpp
//1. 认识引用
void test01(){
	int a = 10;
	//给变量a取一个别名b
	int& b = a;
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "------------" << endl;
	//操作b就相当于操作a本身
	b = 100;
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "------------" << endl;
	//一个变量可以有n个别名
	int& c = a;
	c = 200;
	cout << "a:" << a << endl;
	cout << "b:" << b << endl;
	cout << "c:" << c << endl;
	cout << "------------" << endl;
	//a,b,c的地址都是相同的
	cout << "a:" << &a << endl;
	cout << "b:" << &b << endl;
	cout << "c:" << &c << endl;
}
//2. 使用引用注意事项
void test02(){
	//1) 引用必须初始化
	//int& ref; //报错:必须初始化引用
	//2) 引用一旦初始化，不能改变引用
	int a = 10;
	int b = 20;
	int& ref = a;
	ref = b; //不能改变引用
	//3) 不能建立包含引用元素的数组。
	int arr[10];
	//int& ref3[10] = arr;//是不合法的，因为 C++ 不允许声明一个包含引用元素的数组。
}
//1. 建立数组引用方法一
	typedef int ArrRef[10];
	int arr[10];
	ArrRef& aRef = arr;
	for (int i = 0; i < 10;i ++){
		aRef[i] = i+1;
	}
	for (int i = 0; i < 10;i++){
		cout << arr[i] << " ";
	}
	cout << endl;
	//2. 建立数组引用方法二
	int(&f)[10] = arr;
	for (int i = 0; i < 10; i++){
		f[i] = i+10;
	}
	for (int i = 0; i < 10; i++){
		cout << arr[i] << " ";
	}
	cout << endl;
```

> **建立数组引用方法解析：**
>
> **方法一：**
>
> 1. **1. 定义数组类型别名**：
>
>    ```cpp
>    typedef int ArrRef[10];
>    ```
>
>    这段代码中，`ArrRef` 被定义为一个包含 10 个 `int` 元素的数组类型。可以通过 `ArrRef` 来引用这种数组类型。
>
> 2. **2. 引用数组**：
>
>    ```cpp
>    ArrRef& aRef = arr;
>    ```
>
>    这一行代码创建了一个对 `ArrRef` 类型的引用 `aRef`，并将其初始化为 `arr`。由于 `ArrRef` 实际上是 `int[10]`
>
> **方法二：**
>
> 1. **1. 明确int& f[10]，int[10]& f，int(&f)[10]，和int(& f)[10]的意思和关系：**
>    - **int& f[10]：**该声明试图创建一个“引用数组”，即一个包含10个`int`引用类型的数组。此声明不合法。C++不允许创建“引用数组”。原因是引用一旦绑定一个对象，就不能再改变其绑定对象，而数组要求每个元素独立存在。因此，`int& f[10];`会产生语法错误。
>    - **int[10]& f：**该声明试图创建“数组的引用”，即一个包含10个`int`元素的数组的引用类型，同**int(&f)[10]**含义相同**。**此声明也是非法的。这种写法没有明确的变量名称，同时类型和引用符号的顺序也不符合C++的语法规则，C++ 中的数组引用必须遵循“先类型，再括号，再数组大小”的形式。。
>    - **int(&f)[10]：**这是一个对数组的引用，表示`f`是一个对`int`数组的引用，该数组包含10个`int`元素。换句话说，`f`引用一个包含10个`int`类型元素的数组，可以通过引用`f`来操作原数组中的元素。此声明是合法的。
>    - **int(& f)[10]：**这一声明与上一个（`int(&f)[10]`）等价。空格不影响语义，因此`int(& f)[10]`也是对一个包含10个`int`元素的数组的引用声明。此声明也是合法的。
> 2. **2. int(&f)[10] = arr：表示**`f` 是对一个包含 10 个整数元素的数组的引用，即`f` 是对数组 `arr` 的引用

### **3.10.2 函数中的引用**

最常见看见引用的地方是在函数参数和返回值中。当引用被用作函数参数的时，在函数内对任何引用的修改，将对函数外的参数产生改变。当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。

如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。

```cpp
//值传递
void ValueSwap(int m,int n){
	int temp = m;
	m = n;
	n = temp;
}
//地址传递
void PointerSwap(int* m,int* n){
	int temp = *m;
	*m = *n;
	*n = temp;
}
//引用传递
void ReferenceSwap(int& m,int& n){
	int temp = m;
	m = n;
	n = temp;
}
void test(){
	int a = 10;
	int b = 20;
	//值传递
	ValueSwap(a, b);
	cout << "a:" << a << " b:" << b << endl;
	//地址传递
	PointerSwap(&a, &b);
	cout << "a:" << a << " b:" << b << endl;
	//引用传递
	ReferenceSwap(a, b);
	cout << "a:" << a << " b:" << b << endl;
```

通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单：

1. 函数调用时传递的实参不必加"&"符
2. 在被调函数中不必在参数前加"*"符

引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。

```cpp
//返回局部变量引用
int& TestFun01(){
	int a = 10; //局部变量
	return a;
}
//返回静态变量引用
int& TestFunc02(){	
	static int a = 20;
	cout << "static int a : " << a << endl;
	return a;
}
int main(){
	//不能返回局部变量的引用
	int& ret01 = TestFun01();
	//如果函数做左值，那么必须返回引用
	TestFunc02();
	TestFunc02() = 100;
	TestFunc02();

	return EXIT_SUCCESS;
}
```

- 不能返回局部变量的引用。
- 函数当左值，必须返回引用。

### **3.10.3 引用的本质**

**引用的本质在c++内部实现是一个指针常量.**

```
Type& ref = val; // Type* const ref = &val;
```

c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。

```cpp
//发现是引用，转换为 int* const ref = &a;
void testFunc(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
	int& aRef = a; //自动转换为 int* const aRef = &a;这也能说明引用为什么必须初始化
	aRef = 20; //内部发现aRef是引用，自动帮我们转换为: *aRef = 20;
	cout << "a:" << a << endl;
	cout << "aRef:" << aRef << endl;
	testFunc(a);
	return EXIT_SUCCESS;
}
```

### **3.10.4 指针引用**

在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样:

```c
void fun(int** ptr)
```

> 在 C 语言中，若想通过函数改变指针的指向而不是修改其指向的内容，通常会使用**二级指针**（即指向指针的指针）。`void fun(int** ptr);` 的声明即是一个典型的二级指针参数的函数定义。
>
> **解释**
>
> `int** ptr` 表示 `ptr` 是一个指向 `int*` 的指针。换句话说，`ptr` 的类型是“指向指针的指针”，这样它可以指向一个 `int*` 类型的变量（即普通的一级指针）。
>
> - 当我们传入 `int**` 类型参数时，可以通过它间接修改原始指针的指向，而不仅仅是修改指针指向的数据。
>
> **示例代码**
>
> 以下代码演示了 `void fun(int** ptr);` 的用法：
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> 
> void fun(int** ptr) {
>     *ptr = (int*)malloc(sizeof(int));  // 修改 ptr 的指向
>     if (*ptr != NULL) {
>         **ptr = 10;  // 通过分配的内存修改值
>     }
> }
> 
> int main() {
>     int* p = NULL;       // 定义一个一级指针并初始化为 NULL
>     printf("Before: p = %p\n", (void*)p);
> 
>     fun(&p);             // 将 p 的地址传入函数 fun
> 
>     if (p != NULL) {
>         printf("After: p = %p, *p = %d\n", (void*)p, *p);  // p 的指向被改变
>         free(p);          // 释放分配的内存
>     }
> 
>     return 0;
> }
> ```
>
> **代码分析**
>
> 1. **定义一级指针** `p` ：在 `main` 中，`p` 是一个 `int*` 类型的指针，初始化为 `NULL`，表示它暂时不指向任何有效内存。
> 2. **调用** `fun(&p)` ：在调用 `fun` 函数时，我们将 `p` 的地址传递给函数，因此在 `fun` 中接收到的是一个 `int**` 类型的指针。
> 3. **修改指针指向**：在 `fun` 中，通过 `*ptr = (int*)malloc(sizeof(int));` 为 `p` 分配了一个新内存块，从而改变了 `p` 的指向。此时，`p` 指向一块有效内存，而不再是 `NULL`。
> 4. **修改指向内容**：在 `fun` 中，通过 `**ptr = 10;` 赋值，可以为这块新内存赋值。
> 5. **输出结果**：在 `main` 函数中，`p` 的指向已经改变，不再是 `NULL`，同时其指向的内容也已更新为 `10`。
>
> **图解**
>
> 1. 调用前：![2024-11-18_10-03-00.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/2024-11-18_10-03-00.png)
> 2. 调用后：![2024-11-18_10-04-37.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/2024-11-18_10-04-37.png)
>
> **总结**
>
> - **传递二级指针**的作用是能够修改一级指针的指向。
> - 在函数中通过 `*ptr = ...` 可以重新为原始指针分配新的内存地址或改变指向的对象，从而间接修改原始指针的值。

给指针变量取一个别名:

```c
Type* pointer = NULL;
```

如果你想为这个指针取一个别名，可以使用如下的方式：

```c
Type*& alias = pointer;
struct Teacher{
	int mAge;
};
//指针间接修改teacher的年龄
void AllocateAndInitByPointer(Teacher** teacher){
	*teacher = (Teacher*)malloc(sizeof(Teacher));
	(*teacher)->mAge = 200;  
}
//引用修改teacher年龄
void AllocateAndInitByReference(Teacher*& teacher){
	teacher->mAge = 300;
}
void test(){
	//创建Teacher
	Teacher* teacher = NULL;
	//指针间接赋值
	AllocateAndInitByPointer(&teacher);
	cout << "AllocateAndInitByPointer:" << teacher->mAge << endl;
	//引用赋值,将teacher本身传到ChangeAgeByReference函数中
	AllocateAndInitByReference(teacher);
	cout << "AllocateAndInitByReference:" << teacher->mAge << endl;
	free(teacher);
}
```

对于c++中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。

### **3.10.5 常量引用**

常量引用的定义格式

```cpp
const Type& ref = val;
```

常量引用注意：

- 字面量不能赋给引用，但是可以赋给const引用
- const修饰的引用，不能修改。

```cpp
void test01(){
	int a = 100;
	const int& aRef = a; //此时aRef就是a
	//aRef = 200; 不能通过aRef的值
	a = 200; //OK
	cout << "a:" << a << endl;
	cout << "aRef:" << aRef << endl;
}
void test02(){
	//不能把一个字面量赋给引用
	//int& ref = 100;
	//但是可以把一个字面量赋给常引用
	const int& ref = 100; //int temp = 200; const int& ret = temp;
}
```

> **[const引用使用场景]**
>
> 常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。
>
> 将函数的形参定义为常量引用的好处:
>
> 引用不产生新的变量，减少形参与实参传递时的开销。
>
> 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。
>
> 如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。

```cpp
//const int& param防止函数中意外修改数据
void ShowVal(const int& param){
	cout << "param:" << param << endl;
}
```

## **3.11 内联函数(inline function)**

### **3.11.1 内联函数的引出**

c++从c中继承的一个重要特征就是效率。假如c++的效率明显低于c的效率，那么就会有很大的一批程序员不去使用c++了。

在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。

但是在c++出现之后，使用预处理宏会出现两个问题：

- 第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。
- 第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员函数。

为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function).

内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。

### **3.11.2 预处理宏的缺陷**

预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为是一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因为也容易被混淆。但是其中也会有一些微妙的问题出现:

问题一：

```cpp
#define ADD(x,y) x+y
inline int Add(int x,int y){
	return x + y;
}
void test(){
	int ret1 = ADD(10, 20) * 10; //希望的结果是300
	int ret2 = Add(10, 20) * 10; //希望结果也是300
	cout << "ret1:" << ret1 << endl; //210
	cout << "ret2:" << ret2 << endl; //300
}
```

> 在你的代码中，宏 `ADD(x, y)` 被定义为 `x + y`。在 `test` 函数中，调用 `ADD(10, 20) * 10` 时，预处理器会直接将宏展开为 `10 + 20 * 10`，由于宏的文本替换不会添加额外的括号，结果表达式就是 `10 + 20 * 10`。
>
> 根据 C 语言的运算优先级，乘法优先于加法，因此表达式会被计算为：
>
> ```cpp
> 10 + (20 * 10) = 10 + 200 = 210
> ```
>
> 这就解释了为什么 `ret1` 的值是 `210`。
>
> **解决方法**
>
> 要确保 `ADD(x, y)` 宏计算时按预期的方式处理，可以在宏的定义中添加括号，使宏参数和整体表达式都被括起来。这样能确保优先级正确处理：
>
> ```cpp
> #define ADD(x, y) ((x) + (y))
> ```
>
> 这样，`ADD(10, 20) * 10` 会被展开为 `((10) + (20)) * 10`，从而按照预期计算成 `300`。

问题二：

```cpp
#define COMPARE(x,y) ((x) < (y) ? (x) : (y))
int Compare(int x,int y){
	return x < y ? x : y;
}
void test02(){
	int a = 1;
	int b = 3;
	//cout << "COMPARE(++a, b):" << COMPARE(++a, b) << endl; // 3
	cout << "Compare(int x,int y):" << Compare(++a, b) << endl; //2
}
```

> 在宏 `COMPARE(++a, b)` 展开过程中，传入的参数会被多次使用，因此导致副作用问题。
>
> 具体来说，宏 `COMPARE(x, y)` 被定义为 `((x) < (y) ? (x) : (y))`，并不会像函数一样在执行前对参数求值，而是将参数 `x` 和 `y` 按文本直接插入。所以，调用 `COMPARE(++a, b)` 会被预处理器直接替换为：
>
> ```cpp
> ((++a) < (b) ? (++a) : (b))
> ```
>
> 这个展开后的表达式中，`++a` 被执行了两次：
>
> 1. `(++a) < (b)` 首次对 `a` 自增，结果是 `a = 2`，判断条件为 `2 < 3`，成立。
> 2. 由于条件成立，会返回 `(x)` 部分的 `++a`，再次自增，使 `a = 3`，返回结果 `3`。
>
> 因此，最终输出 `3`，而非预期的 `2`。

问题三:

预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说预定义宏没有办法表示类的范围。

### **3.11.3 内联函数**

#### **3.11.3.1 内联函数基本概念**

在c++中，预定义宏的概念是用内联函数来实现的，而**内联函数本身也是一个真正的函数**。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。

- 在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。

> **定义内联函数的条件**
> 如果只在函数声明前加上`inline`关键字（例如：`inline void func(int a);`），并没有实际作用，因为这只是函数的**声明**，没有函数体的定义。所以编译器不会知道如何将其展开为内联。
>
> **正确的定义方法**
> 要使函数真正成为内联函数，需要在**定义**时写出完整的函数体，例如：
>
> ```cpp
> inline int func(int a) { return ++a; }
> ```
>
> 这种写法包含了函数体，因此编译器能够在函数调用时尝试将代码展开成内联。

注意: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。

> **编译器行为**
> 编译器在处理内联函数时会进行检查，包括参数类型匹配、返回值类型检查等。这些是由编译器而非预处理器完成的。
>
> **预处理器与编译器的区别**
> 预处理器主要在编译前进行宏替换等操作，不具备类型检查功能；而编译器会在编译时进行语法、类型等检查，确保内联函数调用的正确性。

内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以**空间换时间**。

#### **3.11.3.2 类内部的内联函数**

为了定义内联函数，通常必须在函数定义前面放一个inline关键字。但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数自动成为内联函数。

```cpp
class Person{
public:
	Person(){ cout << "构造函数!" << endl; }
	void PrintPerson(){ cout << "输出Person!" << endl; }
}
```

构造函数Person，成员函数PrintPerson在类的内部定义，自动成为内联函数。

#### **3.11.3.3 内联函数和编译器**

内联函数并不是何时何地都有效，为了理解内联函数何时有效，应该要知道编译器碰到内联函数会怎么处理？

对于任何类型的函数，编译器会将函数类型(包括函数名字，参数类型，返回值类型)放入到符号表中。同样，当编译器看到内联函数，并且对内联函数体进行分析没有发现错误时，也会将内联函数放入符号表。

当调用一个内联函数的时候，编译器首先确保传入参数类型是正确匹配的，或者如果类型不正完全匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。假如内联函数是成员函数，对象this指针也会被放入合适位置。

类型检查和类型转换、包括在合适位置放入对象this指针这些都是预处理器不能完成的。

但是c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：

（1）不能存在任何形式的循环语句

（2）不能存在过多的条件判断语句

（3）函数体不能过于庞大

（4）不能对函数进行取址操作

**内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。**

## **3.12 函数的默认参数**

c++在声明函数原型时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。

```cpp
void TestFunc01(int a = 10, int b = 20){
	cout << "a + b  = " << a + b << endl;
}
//注意点:
//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数
void TestFunc02(int a,int b = 10,int c = 10){}
//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数
void TestFunc03(int a = 0,int b = 0);
void TestFunc03(int a, int b){}

int main(){
	//1.如果没有传参数，那么使用默认参数
	TestFunc01();
	//2. 如果传一个参数，那么第二个参数使用默认参数
	TestFunc01(100);
	//3. 如果传入两个参数，那么两个参数都使用我们传入的参数
	TestFunc01(100, 200);

	return EXIT_SUCCESS;
}
```

**注意点：**

- 函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。
- 如果函数声明和函数定义分开写，函数声明和函数定义不能同时设置默认参数。

## **3.13 函数的占位参数**

c++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。

```cpp
void TestFunc01(int a,int b,int){
	//函数内部无法使用占位参数
	cout << "a + b = " << a + b << endl;
}
//占位参数也可以设置默认值
void TestFunc02(int a, int b, int = 20){
	//函数内部依旧无法使用占位参数
	cout << "a + b = " << a + b << endl;
}
int main(){

	//错误调用，占位参数也是参数，必须传参数
	//TestFunc01(10,20); 
	//正确调用
	TestFunc01(10,20,30);
	//正确调用
	TestFunc02(10,20);
	//正确调用
	TestFunc02(10, 20, 30);

	return EXIT_SUCCESS;
}
```

什么时候用，在后面我们要讲的操作符重载的后置++要用到这个.

## **3.14 函数重载(overload)**

### **3.14.1 函数重载概述**

**能使名字方便使用，是任何程序设计语言的一个重要特征！**

> 我们现实生活中经常会碰到一些字在不同的场景下具有不同的意思，比如汉语中的多音字"重"。
>
> 当我们说: "他好重啊，我都背不动!"我们根据上下文意思，知道"重"在此时此地表示重量的意思。
>
> 如果我们说"你怎么写了那么多重复的代码? 维护性太差了!"这个地方我们知道，"重"表示重复的意思。

同样一个字在不同的场景下具有不同的含义。那么在c++中也有一种类似的现象出现，同一个函数名在不同场景下可以具有不同的含义。

在传统c语言中，函数名必须是唯一的，程序中不允许出现同名的函数。在c++中是允许出现同名的函数，这种现象称为函数重载。

函数重载的目的就是为了方便的使用函数名。

函数重载并不复杂，等大家学完就会明白什么时候需要用到他们，以及是如何编译，链接的。

### **3.14.2 函数重载**

#### **3.14.2.1 函数重载基本语法**

**实现函数重载的条件：**

- 同一个作用域
- 参数个数不同
- 参数类型不同
- 参数顺序不同

```cpp
//1. 函数重载条件
namespace A{
	void MyFunc(){ cout << "无参数!" << endl; }
	void MyFunc(int a){ cout << "a: " << a << endl; }
	void MyFunc(string b){ cout << "b: " << b << endl; }
	void MyFunc(int a, string b){ cout << "a: " << a << " b:" << b << endl;}
    void MyFunc(string b, int a){cout << "a: " << a << " b:" << b << endl;}
}
//2.返回值不作为函数重载依据
namespace B{
	void MyFunc(string b, int a){}
	//int MyFunc(string b, int a){} //无法重载仅按返回值区分的函数
}
```

**注意:** 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。

```cpp
void MyFunc(string b){
	cout << "b: " << b << endl;
}
//函数重载碰上默认参数
void MyFunc(string b, int a = 10){
	cout << "a: " << a << " b:" << b << endl;
}
int main(){
	MyFunc("hello"); //这时，两个函数都能匹配调用，产生二义性，运行报错
	return 0;
}
```

**思考：**为什么函数返回值不作为重载条件呢？

当编译器能从上下文中确定唯一的函数的时，如int ret = func(),这个当然是没有问题的。然而，我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数为

void func(int x);另一个为int func(int x); 当我们直接调用func(10),这个时候编译器就不确定调用那个函数。所以在c++中禁止使用返回值作为重载的条件。

#### **3.14.2.2 函数重载实现原理**

编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成*func，*当编译器碰到void func(int x),编译器可能将函数名修饰为func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char我这里使用"可能"这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。

```cpp
void func(){}
void func(int x){}
void func(int x,char y){}
```

以上三个函数在linux下生成的编译之后的函数名为:

```cpp
_Z4funcv //v 代表void,无参数
_Z4funci //i 代表参数为int类型
_Z4funcic //i 代表第一个参数为int类型，第二个参数为char类型
```

### **3.14.3 extern "C"浅析**

以下在Linux下测试:

```cpp
c函数: void MyFunc(){} ,被编译成函数: MyFunc
c++函数: void MyFunc(){},被编译成函数: _Z6Myfuncv
```

通过这个测试，由于c++中需要支持函数重载，所以c和c++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，以上例，c++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。

那么如果我想在c++调用c的函数怎么办？

extern "C"的主要作用就是为了实现c++代码能够调用其他c语言代码。加上extern "C"后，这部分代码编译器按c语言的方式进行**编译**和**链接**，而不是按c++的方式。

**示例（三个代码文件）：**

**MyModule.h**

```c
#ifndef MYMODULE_H
#define MYMODULE_H

#include<stdio.h>

#if __cplusplus
extern "C"{
#endif

	void func1();
	int func2(int a,int b);

#if __cplusplus
}
#endif

#endif
```

> 这段代码是一个典型的C/C++头文件，文件名通常为 `MyModule.h`，主要用来声明函数、变量或其他符号，使其可以在不同的源文件之间共享。以下是该代码的详细解析：
>
> **代码分解与解释**
>
> **1. 头文件保护机制**
>
> ```c
> #ifndef MYMODULE_H
> #define MYMODULE_H
> ...
> #endif
> ```
>
> - `#ifndef MYMODULE_H` 和 `#define MYMODULE_H` ：这是**头文件保护机制**。目的是避免头文件被重复包含。
>   - 当代码中多次包含同一个头文件时（例如使用 `#include "MyModule.h"`），若没有保护机制，将会引发重复定义错误。
>   - `#ifndef`（if not defined）指令会检查 `MYMODULE_H` 是否已定义。
>   - 如果未定义，接下来的 `#define MYMODULE_H` 就会定义这个标识符，并包含随后的代码。
>   - `#endif` 则标记了条件编译的结束（`#ifndef`指令相对应的结束符号）。当该文件再次被包含时，由于 `MYMODULE_H` 已定义，`#ifndef` 检查不成立，因此会跳过整个文件内容，避免重复定义。
>
> **2. 包含标准库头文件**
>
> ```c
> #include <stdio.h>
> ```
>
> - `#include <stdio.h>` ：包含C语言的标准输入输出头文件 `stdio.h`，提供了 `printf`、`scanf` 等标准输入输出函数。
> - 这一步确保该头文件的实现文件可以直接调用 `printf` 等 I/O 函数。
>
> **3.** `extern "C"` 块
>
> ```c
> #if __cplusplus
> extern "C" {
> #endif
> ...
> #if __cplusplus
> }
> #endif
> ```
>
> - `#if __cplusplus` ：检查当前编译环境是否为 C++。`__cplusplus` 是一个由C++编译器定义的宏，用来区分编译语言。
>   - 若为C++编译环境，则 `__cplusplus` 宏存在，代码段内的 `extern "C"` 就会生效；如果是 C 编译器，则不会包含这部分代码。
> - `extern "C" { ... }` ：这是 **C语言链接指示符**。
>   - 在C++中，函数会使用**名称修饰（name mangling）** 以支持重载。名称修饰会在函数名中加入额外信息（如参数类型），生成唯一符号来区分重载函数。
>   - 而C语言不支持函数重载，也不使用名称修饰，因此其符号较为简单。
>   - `extern "C"` 指示编译器对括号内的函数声明使用C语言的链接方式，从而保持C和C++编译器生成的符号一致，使得C++代码可以调用C语言的实现。
>
> **4. 函数声明**
>
> ```c
> void func1();
> int func2(int a, int b);
> ```
>
> - `void func1();` 和 `int func2(int a, int b);` ：这两行声明了 `func1` 和 `func2` 函数。
>   - `func1` 是一个无参数、无返回值的函数，可能用于打印消息或执行简单任务。
>   - `func2` 是一个带有两个 `int` 类型参数并返回一个 `int` 值的函数，可能用于执行简单计算，例如两个整数的加法。
> - 在头文件中声明函数，使得其他文件可以调用这些函数，而无需知道其具体实现细节。这种做法符合软件设计的**接口与实现分离**原则，便于模块化和复用。
>
> **整体功能**
>
> - 这段代码声明了 `func1` 和 `func2`，并使用 `extern "C"` 语句确保函数可以在C++中调用。这种结构常用于希望实现代码可以跨C和C++两种语言复用的场景。例如：
>   - C++代码可以直接调用C语言库函数。
>   - 可以避免链接时的符号冲突和不兼容问题。
>
> **使用场景**
>
> 此头文件的典型用法是在C和C++混合编程项目中，例如：
>
> - 一个C语言实现的库需要被C++项目调用。
> - 项目中存在大量C语言代码，需要C++代码在不改动原有C代码的情况下直接使用它们。

**MyModule.c**

```c
#include"MyModule.h"

void func1(){
	printf("hello world!");
}
int func2(int a, int b){
	return a + b;
}
```

**TestExternC.cpp**

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;

#if 0

	#ifdef __cplusplus
	extern "C" {
		#if 0
			void func1();
			int func2(int a, int b);
		#else
			#include"MyModule.h"
		#endif
	}

	#endif

#else

	extern "C" void func1();
	extern "C" int func2(int a, int b);

#endif

int main(){
	func1();
	cout << func2(10, 20) << endl;
	return EXIT_SUCCESS;
}
```

> 这段代码实现了 C 和 C++ 的兼容编程。主要功能是调用 `MyModule.h` 中声明的两个 C 函数 `func1` 和 `func2`，并确保在 C++ 中正确使用 C 函数声明。以下是代码的结构和详细解释：
>
> **代码分析**
>
> **第一行：禁用安全警告**
>
> ```c
> #define _CRT_SECURE_NO_WARNINGS
> ```
>
> 该宏用于在编译器中禁用关于“非安全”函数（如 `scanf` 等）的警告信息，常用于 Visual Studio 环境中。
>
> **包含头文件**
>
> ```javascript
> #include<iostream>
> using namespace std;
> ```
>
> 包含了 C++ 标准输入输出库 `iostream`，使得代码可以使用 `cout` 等 C++ 输入输出流。
>
> **条件编译和** `extern "C"` 使用
>
> **第一层** `#if 0` 块
>
> ```cpp
> #if 0
>     ...
> #else
>     ...
> #endif
> ```
>
> - `#if 0` 表示条件编译，意味着该块中的代码不会被编译。
> - `#else` 下方的代码块则会被编译。这一结构通常用于控制代码的多种实现或不同编译环境。
>
> `#if 0` 块内部代码
>
> 假设将 `#if 0` 改为 `#if 1`，这一块代码会被编译，内容如下：
>
> ```cpp
> #ifdef __cplusplus
> extern "C" {
>     #if 0
>         void func1();
>         int func2(int a, int b);
>     #else
>         #include"MyModule.h"
>     #endif
> }
> #endif
> ```
>
> 1. `__cplusplus` 宏：检查是否在 C++ 环境中。如果是 C++ 编译器，则定义 `extern "C" { ... }`，确保使用 C 链接方式。
> 2. **嵌套** `#if 0` 块：
>    - 如果 `#if 0` 改为 `#if 1`，则会声明 `func1` 和 `func2` 函数。
>    - 否则包含 `#include "MyModule.h"`，引用头文件中声明的 `func1` 和 `func2`。
>
> 在这种结构下，`#if 0` 使得两种定义方式互斥，不会重复声明函数。
>
> `#else` 块：直接声明 C 函数
>
> 由于代码实际编译的是 `#else` 块内容：
>
> ```cpp
> extern "C" void func1();
> extern "C" int func2(int a, int b);
> ```
>
> 这段代码直接在 C++ 环境中声明 `func1` 和 `func2`，并使用 `extern "C"` 确保它们按 C 链接方式处理。
>
> **主函数** `main()`
>
> ```cpp
> int main(){
>     func1();
>     cout << func2(10, 20) << endl;
>     return EXIT_SUCCESS;
> }
> ```
>
> 1. **调用** `func1()` ：调用 `func1` 函数。
> 2. **调用** `func2(10, 20)` 并输出结果：调用 `func2`，传入 `10` 和 `20`，并使用 `cout` 输出结果。
> 3. **返回** `EXIT_SUCCESS` ：返回标准的成功标志。
>
> **代码的整体作用**
>
> 该代码通过条件编译、`extern "C"`、头文件包含控制，灵活地管理 C 和 C++ 代码的链接与编译，实现了对 `func1` 和 `func2` 函数的调用。在主函数中，`func1` 被调用，而 `func2` 的结果被输出。

# **4. 类和对象**

## **4.1 类和对象的基本概念**

### **4.1.1 C和C++中struct区别**

- c语言struct只有变量
- c++语言struct 既有变量，也有函数

### **4.1.2 类的封装**

我们编写程序的目的是为了解决现实中的问题，而这些问题的构成都是由各种事物组成，我们在计算机中要解决这种问题，首先要做就是要将这个问题的参与者：事和物抽象到计算机程序中，也就是用程序语言表示现实的事物。

那么现在问题是如何用程序语言来表示现实事物？现实世界的事物所具有的共性就是每个事物都具有自身的属性，一些自身具有的行为，所以如果我们能把事物的属性和行为表示出来，那么就可以抽象出来这个事物。

比如我们要表示人这个对象，在c语言中，我们可以这么表示:

```c
typedef struct _Person{
	char name[64];
	int age;
}Person;
typedef struct _Aninal{
	char name[64];
	int age;
	int type; //动物种类
}Ainmal;

void PersonEat(Person* person){
	printf("%s在吃人吃的饭!\n",person->name);
}
void AnimalEat(Ainmal* animal){
	printf("%s在吃动物吃的饭!\n", animal->name);
}

int main(){

	Person person;
	strcpy(person.name, "小明");
	person.age = 30;
	AnimalEat(&person);//这里报错

	return EXIT_SUCCESS;
}
```

定义一个结构体用来表示一个对象所包含的属性，函数用来表示一个对象所具有的行为，这样我们就表示出来一个事物，在c语言中，行为和属性是分开的，也就是说吃饭这个属性不属于某类对象，而属于所有的共同的数据，所以不单单是PeopleEat可以调用Person数据，AnimalEat也可以调用Person数据，那么万一调用错误，将会导致问题发生。

从这个案例我们应该可以体会到，属性和行为应该放在一起，一起表示一个具有属性和行为的对象。

假如某对象的某项属性不想被外界获知，比如说漂亮女孩的年龄不想被其他人知道，那么年龄这条属性应该作为女孩自己知道的属性；或者女孩的某些行为不想让外界知道，只需要自己知道就可以。那么这种情况下，封装应该再提供一种机制能够给属性和行为的访问权限控制住。

所以说封装特性包含两个方面，一个是属性和函数合成一个整体，一个是给属性和函数增加访问权限。

- 封装

1. 把变量（属性）和函数（操作）合成一个整体，封装在一个类中
2. 对变量和函数进行访问控制

- 访问权限

1. 在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问
2. 在类的外部(作用域范围外)，访问权限才有意义：public，private，protected
3. 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时， private和protected是同等级的，外部不允许访问![2024-11-11_15-16-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-16-09.png.png)

```cpp
//封装两层含义
//1. 属性和行为合成一个整体
//2. 访问控制，现实事物本身有些属性和行为是不对外开放
class Person{
//人具有的行为(函数)
public:
	void Dese(){ cout << "我有钱，年轻，个子又高，就爱嘚瑟!" << endl;}
//人的属性(变量)
public:
	int mTall; //多高，可以让外人知道
protected:
	int mMoney; // 有多少钱,只能儿子孙子知道
private:
	int mAge; //年龄，不想让外人知道
};
int main(){

	Person p;
	p.mTall = 220;
	//p.mMoney 保护成员外部无法访问
	//p.mAge 私有成员外部无法访问
	p.Dese();

	return EXIT_SUCCESS;
}
```

**struct和class的区别?**

class默认访问权限为private,struct默认访问权限为public.

```cpp
class A{
	int mAge;
};
struct B{
	int mAge;
};

void test(){
	A a;
	B b;
	//a.mAge; //无法访问私有成员
	b.mAge; //可正常外部访问
}
```

### **4.1.3 将成员变量设置为private**

1. 可赋予客户端访问数据的一致性。

> 如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。

1. 可细微划分访问控制。

> 使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为public，每个人都可以读写它。如果我们设置为private，我们可以实现"不准访问"、"只读访问"、"读写访问"，甚至你可以写出"只写访问"。

```cpp
class AccessLevels{
public:
	//对只读属性进行只读访问
	int getReadOnly(){ return readOnly; }
	//对读写属性进行读写访问
	void setReadWrite(int val){ readWrite = val; }
	int getReadWrite(){ return readWrite; }
	//对只写属性进行只写访问
	void setWriteOnly(int val){ writeOnly = val; }
private:
	int readOnly; //对外只读访问
	int noAccess; //外部不可访问
	int readWrite; //读写访问
	int writeOnly; //只写访问
};
```

## **4.2 面向对象程序设计案例**

### **4.2.1 设计立方体类**

设计立方体类(Cube)，求出立方体的面积( 2*a*b + 2*a*c + 2*b*c )和体积( a *b* c)，分别用全局函数和成员函数判断两个立方体是否相等。![2024-11-11_15-17-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-17-09.png.jpeg)

```cpp
//立方体类
class Cub{
public:
	void setL(int l){ mL = l; }
	void setW(int w){ mW = w; }
	void setH(int h){ mH = h; }
	int getL(){ return mL; }
	int getW(){ return mW; }
	int getH(){ return mH; }
	//立方体面积
	int caculateS(){ return (mL*mW + mL*mH + mW*mH) * 2; }
	//立方体体积
	int caculateV(){ return mL * mW * mH; }
	//成员方法
	bool CubCompare(Cub& c){
		if (getL() == c.getL() && getW() == c.getW() && getH() == c.getH()){
			return true;
		}
		return false;
	}
private:
	int mL; //长
	int mW; //宽
	int mH; //高
};

//比较两个立方体是否相等
bool CubCompare(Cub& c1, Cub& c2){
	if (c1.getL() == c2.getL() && c1.getW() == c2.getW() && c1.getH() == c2.getH()){
		return true;
	}
	return false;
}
```

### **4.2.2 点和圆的关系**

设计一个圆形类（AdvCircle），和一个点类（Point），计算点和圆的关系。

假如圆心坐标为x0, y0, 半径为r，点的坐标为x1, y1：

1. 点在圆上：(x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) == r*r
2. 点在圆内：(x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) < r*r
3. 点在圆外：(x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) > r*r

```cpp
//点类
class Point{
public:
	void setX(int x){ mX = x; }
	void setY(int y){ mY = y; }
	int getX(){ return mX; }
	int getY(){ return mY; }
private:
	int mX;
	int mY;
};

//圆类
class Circle{
public:
	void setP(int x,int y){
		mP.setX(x);
		mP.setY(y);
	}
	void setR(int r){ mR = r; }
	Point& getP(){ return mP; }
	int getR(){ return mR; }
	//判断点和圆的关系
	void IsPointInCircle(Point& point){
		int distance = (point.getX() - mP.getX()) * (point.getX() - mP.getX()) + (point.getY() - mP.getY()) * (point.getY() - mP.getY());
		int radius = mR * mR;
		if (distance < radius){
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆内!" << endl;
		}
		else if (distance > radius){
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆外!" << endl;
		}
		else{
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆上!" << endl;
		}
	}
private:
	Point mP; //圆心
	int mR; //半径
};

void test(){
	//实例化圆对象
	Circle circle;
	circle.setP(20, 20);
	circle.setR(5);
	//实例化点对象
	Point point;
	point.setX(25);
	point.setY(20);

	circle.IsPointInCircle(point);
}
```

## **4.3 对象的构造和析构**

### **4.3.1 初始化和清理**

我们大家在购买一台电脑或者手机，或者其他的产品，这些产品都有一个初始设置，也就是这些产品被创建的时候会有一个基础属性值。那么随着我们使用手机和电脑的时间越来越久，那么电脑和手机会慢慢被我们手动创建很多文件数据，某一天我们不用手机或电脑了，那么我们应该将电脑或手机中我们增加的数据删除掉，保护自己的信息数据。

从这样的过程中，我们体会一下，所有的事物在起初的时候都应该有个初始状态，当这个事物完成其使命时，应该及时清除外界作用于上面的一些信息数据。

那么我们c++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们创建对象的时候,这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。

对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。c++为了给我们提供这种问题的解决方案，**构造函数**和**析构函数**，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。

**无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。**

为什么初始化操作是自动调用而不是手动调用？既然是必须操作，那么自动调用会更好，如果靠程序员自觉，那么就会存在遗漏初始化的情况出现。

### **4.3.2 构造函数和析构函数**

构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。

析构函数主要用于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**

构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。

```cpp
ClassName(){}
```

**析构函数语法：**

析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void,不能有参数，不能重载。

```cpp
~ClassName(){}
class Person{
public:
	Person(){
		cout << "构造函数调用!" << endl;
		pName = (char*)malloc(sizeof("John"));
		strcpy(pName, "John");
		mTall = 150;
		mMoney = 100;
	}
	~Person(){
		cout << "析构函数调用!" << endl;
		if (pName != NULL){
			free(pName);
			pName = NULL;
		}
	}
public:
	char* pName;
	int mTall;
	int mMoney;
};

void test(){
	Person person;
	cout << person.pName << person.mTall << person.mMoney << endl;
}
```

> **补充，析构函数的调用时机：**
>
> **1. 对象超出作用域时**
>
> - 当对象的作用域结束时（例如局部变量），析构函数会被自动调用，销毁对象并释放资源。
>
> - 示例：
>
>   cpp
>
>   ```
>   void func() {
>       MyClass obj;  // 构造函数调用
>   }  // 离开作用域时，obj 的析构函数被调用
>   ```
>
> **2. 动态分配的对象使用** `delete` 时
>
> - 对于通过 `new` 操作符动态分配的对象，当使用 `delete` 删除该对象时，析构函数会被调用。
>
> - 示例：
>
>   cpp
>
>   ```
>   MyClass* ptr = new MyClass();  // 构造函数调用
>   delete ptr;  // 析构函数调用
>   ```
>
> **3. 对象生命周期结束时**
>
> - 对于全局变量、静态变量、静态类成员等对象，析构函数会在程序结束时被自动调用，销毁对象并释放资源。
>
> **4. 异常发生时**
>
> - 当程序抛出异常并发生栈展开时，析构函数会在栈展开过程中被自动调用，销毁作用域内的所有局部对象，防止资源泄漏。

### **4.3.3 构造函数的分类及调用**

- 按参数类型：分为无参构造函数和有参构造函数
- 按类型分类：普通构造函数和拷贝构造函数(复制构造函数)

```cpp
class Person{
public:
	Person(){
		cout << "no param constructor!" << endl;
		mAge = 0;
	}
	//有参构造函数
	Person(int age){
		cout << "1 param constructor!" << endl;
		mAge = age;
	}
	//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象
	Person(const Person& person){
		cout << "copy constructor!" << endl;
		mAge = person.mAge;
	}
	//打印年龄
	void PrintPerson(){
		cout << "Age:" << mAge << endl;
	}
private:
	int mAge;
};
//1. 无参构造调用方式
void test01(){
	
	//调用无参构造函数
	Person person1; 
	person1.PrintPerson();

	//无参构造函数错误调用方式
	//Person person2();
	//person2.PrintPerson();
}
//2. 调用有参构造函数
void test02(){
	
	//第一种 括号法，最常用
	Person person01(100);
	person01.PrintPerson();

	//调用拷贝构造函数
	Person person02(person01);
	person02.PrintPerson();

	//第二种 匿名对象(显示调用构造函数)
	Person(200); //匿名对象，没有名字的对象

	Person person03 = Person(300);
	person03.PrintPerson();

	//注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型
	Person person06(Person(400)); //等价于 Person person06 = Person(400);
	person06.PrintPerson();

	//第三种 =号法 隐式转换
	Person person04 = 100; //Person person04 =  Person(100)
	person04.PrintPerson();

	//调用拷贝构造
	Person person05 = person04; //Person person05 =  Person(person04)
	person05.PrintPerson();
}
```

> test02输出：
>
> ![2024-11-13_17-28-39.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/13/2024-11-13_17-28-39.png)
>
> **代码分析test01：**
>
> - **为什么Person person2();是错误的调用方式？**
>
> 在 C++ 中，`Person person2();` 是一种特殊的语法，称为**最具解析性（Most Vexing Parse）** 问题。这种语法实际上不会创建一个 `Person` 类型的对象，而会被编译器解析为一个**函数声明**。
>
> **1.** `Person person2();` 的含义
>
> 在 C++ 中，`Person person2();` 被解析为**声明了一个名为** `person2` 的函数。这个函数没有参数，返回类型为 `Person`。也就是说，编译器认为 `person2` 是一个函数声明，而不是一个对象的定义。因此，实际上并没有创建 `Person` 类的实例，也不会调用无参构造函数 `Person()`。
>
> **2. 为什么会解析成函数声明**
>
> 在 C++ 语法中，任何形如 `Type name();` 的形式通常会被解析为一个**函数声明**，而不是一个对象初始化。编译器默认会选择将这样的语法当成一个函数声明，这种现象就是“最具解析性”问题的根源。
>
> **代码分析test02：**
>
> - **为什么**`Person person03 = Person(300);` **只输出**`1 param constructor!` **？**
>
> 在 C++ 中，语句 `Person person03 = Person(300);` 可能会调用拷贝构造函数，但由于**复制消除（copy elision）** ，实际上编译器可以优化掉这个拷贝构造函数的调用。
>
> **解析过程**
>
> 1. `Person(300)` ：这部分代码创建了一个临时的 `Person` 对象，调用了 **有参构造函数** `Person(int age)`，此时，临时对象 `Person(300)` 被创建，输出：
>
>    ```cpp
>    1 param constructor!
>    ```
>
> 2. `person03 = Person(300);` ：在这里，`person03` 是通过 **拷贝构造函数** 来初始化的，通常编译器会将临时对象 `Person(300)` 传递给 `person03`。因此，理论上应该调用 **拷贝构造函数**，这会将 `Person(300)` 的内容拷贝到 `person03` 中。
>
> **但实际上，C++ 编译器会进行 复制消除（copy elision） ：**
>
> - 在这种情况下，C++ 编译器通常会优化这个拷贝过程。在 `Person person03 = Person(300);` 这行代码中，编译器知道 `person03` 是用临时对象 `Person(300)` 初始化的，它可以直接在 `person03` 的内存空间中构造 `Person(300)`，从而省去临时对象的拷贝过程。
>
> **总结**
>
> - **理论上**，`Person person03 = Person(300);` 会调用拷贝构造函数。
> - **实际上**，由于复制消除，编译器会优化掉拷贝构造函数的调用，直接在 `person03` 的内存中构造 `Person(300)`，因此不会输出拷贝构造函数的调用信息。
> - **为什么**`Person person06(Person(400)); `**也只输出**`1 param constructor!` **？**
>
> 等价于上一个问题（**C++ 编译器会进行 复制消除**），这行代码中，编译器知道 `person06` 是用临时对象 `Person(400)` 初始化的，它可以直接在 `person06` 的内存空间中构造 `Person(400)`，从而省去临时对象的拷贝过程。
>
> - **复制消除是什么？**
>
> 在 C++ 中，**复制消除（copy elision）** 是一种编译器优化技术，用于减少不必要的对象拷贝和移动，从而提高程序的性能。这种优化可以在对象的初始化过程中省去临时对象的构造、拷贝或移动操作，直接在目标对象的内存中构造内容。
>
> **1. 复制消除的典型场景**
>
> 复制消除主要应用于以下两种场景：
>
> - **返回值优化（Return Value Optimization，RVO）** ：当一个函数返回一个局部对象时，如果返回的对象直接用于初始化另一个对象，编译器可以在初始化目标对象的内存中直接构造返回的值，避免额外的拷贝或移动。
> - **临时对象的初始化**：当一个临时对象直接用于初始化另一个对象时，编译器可以优化掉临时对象的拷贝或移动构造函数调用。
>
> 例如：
>
> ```cpp
> Person createPerson() {
>     return Person(30);  // 临时对象直接作为返回值
> }
> 
> Person p = createPerson();
> ```
>
> 在这段代码中，编译器可以在 `p` 的内存空间中直接构造返回的 `Person` 对象，而不会实际创建临时对象 `Person(30)`，从而避免了不必要的拷贝或移动操作。
>
> **2. C++17 的强制复制消除**
>
> 在 **C++17** 标准中，复制消除变成了强制性的，这意味着在某些特定情况下（例如直接返回局部变量、直接初始化的临时对象），编译器必须执行复制消除。这不仅让代码更加高效，也让开发者可以编写更具可预测性的代码。
>
> **3. 复制消除的好处**
>
> - **性能提升**：通过减少不必要的拷贝或移动操作，程序的性能得到了显著提升。
> - **资源利用优化**：减少了临时对象的生成和销毁，降低了资源的使用和内存开销。
>
> **4. 如何查看复制消除是否生效**
>
> 为了查看复制消除是否生效，可以禁用编译器的优化（如使用编译选项 `-fno-elide-constructors`），或者在拷贝构造和移动构造函数中加入输出语句进行测试。如果在特定场景下没有看到拷贝或移动构造函数被调用，则说明复制消除生效了。
>
> 复制消除是 C++ 编译器优化的一个重要特性，尤其是在需要频繁创建和销毁对象的情况下，能大幅度提升程序运行效率。

**注意****:**不能调用拷贝构造函数去初始化匿名对象,也就是说以下代码不正确:

```cpp
class Teacher{
public:
	Teacher(){
		cout << "默认构造函数!" << endl;
	}
	Teacher(const Teacher& teacher){
		cout << "拷贝构造函数!" << endl;
	}
public:
	int mAge;
};
void test(){
	
	Teacher t1;
	//error C2086:“Teacher t1”: 重定义
	Teacher(t1);  //此时等价于 Teacher t1;//这里报错，使用拷贝构造函数初始化匿名对象。
}
```

### **4.3.4 拷贝构造函数的调用时机**

- 对象以值传递的方式传给函数参数
- 函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)（可能会被编译器通过执行返回值优化（RVO）或命名返回值优化（NRVO）将应调的拷贝构造函数优化掉）
- 用一个对象初始化另一个对象

```cpp
class Person{
public:
	Person(){
		cout << "no param contructor!" << endl;
		mAge = 10;
	}
	Person(int age){
		cout << "param constructor!" << endl;
		mAge = age;
	}
	Person(const Person& person){
		cout << "copy constructor!" << endl;
		mAge = person.mAge;
	}
	~Person(){
		cout << "destructor!" << endl;
	}
public:
	int mAge;
};
//1. 旧对象初始化新对象
void test01(){

	Person p(10);
	Person p1(p);
	Person p2 = Person(p);//这里理论上会调用两次构造函数，但因为优化只会调用一次
	Person p3 = p; // 相当于Person p2 = Person(p);
}

//2. 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造
void doBussiness(Person p){}

void test02(){
	Person p(10);
	doBussiness(p);
}

//3. 函数返回局部对象
Person MyBusiness(){
	Person p(10);
	cout << "局部p:" << (int*)&p << endl;
	return p;
}
void test03(){
	//vs release、qt下没有调用拷贝构造函数
	//vs debug下调用一次拷贝构造函数
	Person p = MyBusiness();//这里会有复制消除里的返回值优化，优化掉了拷贝函数
	cout << "局部p:" << (int*)&p << endl;
}
```

**Test03结果说明:**

编译器存在一种对返回值的优化技术,RVO(Return Value Optimization).在vs debug模式下并没有进行这种优化，所以函数MyBusiness中创建p对象，调用了一次构造函数，当编译器发现你要返回这个局部的对象时，编译器通过调用拷贝构造生成一个临时Person对象返回，然后调用p的析构函数。

我们从常理来分析的话，这个匿名对象和这个局部的p对象是相同的两个对象，那么如果能直接返回p对象，就会省去一个拷贝构造和一个析构函数的开销，在程序中一个对象的拷贝也是非常耗时的，如果减少这种拷贝和析构的次数，那么从另一个角度来说，也是编译器对程序执行效率上进行了优化。

所以在这里，编译器偷偷帮我们做了一层优化：

当我们这样去调用: Person p = MyBusiness();

编译器偷偷将我们的代码更改为:

```cpp
void MyBussiness(Person& _result){
       _result.X:X(); //调用Person默认拷贝构造函数
       //.....对_result进行处理
       return;
   }
int main(){
   Person p; //这里只分配空间，不初始化
   MyBussiness(p);
}
```

> **分析Test03结果说明的意思：**
>
> 这段话描述了编译器在函数返回局部对象时可能进行的一种优化，即**返回值优化**（Return Value Optimization，RVO），在一些编译器和模式下也被称为**命名返回值优化**（NRVO）。此优化通过减少拷贝构造函数的调用，提升了返回局部对象时的性能。
>
> **优化过程分析**
>
> 在代码示例中：
>
> ```cpp
> Person MyBusiness(){
>     Person p(10);
>     cout << "局部p:" << (int*)&p << endl;
>     return p;
> }
> ```
>
> 函数`MyBusiness`创建了一个`Person`对象`p`，并试图在返回时复制`p`。在没有RVO的情况下，返回`p`会调用`Person`的拷贝构造函数来生成一个临时对象，并将`p`的数据复制到返回的临时对象中。随后，`p`会被析构（因为`p`的生命周期结束），返回的对象则在`test03`中被接收。这样的复制和销毁增加了不必要的开销。
>
> **RVO的优化过程**
>
> RVO优化了上述过程。编译器通过分析代码结构，直接在调用方的内存空间中创建对象，从而跳过了拷贝构造函数。也就是说，编译器并不真正复制`p`，而是把`p`直接构造在返回位置上。这样就减少了额外的拷贝和析构开销。
>
> 在示例中，RVO在`release`模式下自动生效，因此调用`Person p = MyBusiness();`时，编译器会将代码改写为：
>
> ```cpp
> void MyBusiness(Person& _result) {
>     _result = Person(10);  // 直接在调用者提供的空间中构造对象
>     cout << "局部p:" << (int*)&_result << endl;
>     return;
> }
> int main(){
>     Person p;  // 分配空间但不初始化
>     MyBusiness(p);  // p在MyBusiness内部直接被初始化，无需拷贝
> }
> ```
>
> **解释代码改写**
>
> 在此优化改写的代码中：
>
> - `MyBusiness`函数的返回值变成了一个引用参数`_result`，此参数在调用方`main`中传入，作为最终返回对象的空间。
> - 编译器在调用`MyBusiness`时，将`Person p;`的地址传入作为`_result`的存储位置。因此，`p`在`MyBusiness`内部直接构造，无需拷贝构造和析构临时对象。
> - 调用结束时，直接返回到调用方，使得`p`的构造和返回合为一步。
>
> **编译模式差异**
>
> 在`release`模式下，RVO通常会被启用，而在`debug`模式下可能不会启用（或有差异），因为`debug`模式会增加额外的调试信息和安全检查，使得编译器不一定能进行相同的优化。

### **4.3.5 构造函数调用规则**

- 默认情况下，c++编译器至少为我们写的类增加3个函数

（1）默认构造函数(无参，函数体为空)

（2）默认析构函数(无参，函数体为空)

（3）默认拷贝构造函数，对类中非静态成员属性简单值拷贝

- 如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数
- 如果用户定义了普通构造(非拷贝)，c++不在提供默认无参构造，但是会提供默认拷贝构造

### **4.3.6 深拷贝和浅拷贝**

#### **4.3.6.1 浅拷贝**

同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为**浅拷贝.**

一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间（即堆），析构函数做了动态内存释放的处理，会导致内存问题。

#### ![2024-11-11_15-18-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-18-09.png.png)**4.3.6.2 深拷贝**

当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。

![2024-11-11_15-19-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-19-09.png.png)

```cpp
class Person{
public:
	Person(char* name,int age){
		pName = (char*)malloc(strlen(name) + 1);
		strcpy(pName,name);
		mAge = age;
	}
	//增加拷贝构造函数
	Person(const Person& person){
		pName = (char*)malloc(strlen(person.pName) + 1);
		strcpy(pName, person.pName);
		mAge = person.mAge;
	}
	~Person(){
		if (pName != NULL){
			free(pName);
		}
	}
private:
	char* pName;
	int mAge;
};

void test(){
	Person p1("Edward",30);
	//用对象p1初始化对象p2,调用c++提供的默认拷贝构造函数
	Person p2 = p1;
}
```

> **使用了strlen函数，后面为什么要+1?**
>
> 在这段代码中使用了 `strlen` 后加上 `+1` 是为了为字符串分配足够的内存空间，以容纳**字符串的终止符** `\0`。
>
> **解释** `+1` 的原因
>
> 1. `strlen` 的作用：
>    `strlen` 只计算字符串中的实际字符数，不包括 `\0` 这个终止符。因此，`strlen(name)` 的返回值是字符串的字符数。
> 2. **分配空间时的需求**：
>    在 C 语言风格的字符串中，`'\0'` 是字符串的结束标记，必须包含在分配的内存中。否则，后续操作如 `strcpy` 无法正确地将字符串复制到目标位置，因为 `strcpy` 会一直复制直到遇到 `\0`。
> 3. **加上** `+1` 的作用：
>    `strlen(name) + 1` 为 `pName` 分配了足够的空间来存储 `name` 字符串的所有字符，并在末尾包含一个 `\0`。这保证了字符串的完整性和安全性，避免了因缺少终止符引起的未定义行为。
>
> **如果不加** `+1` 的问题
>
> 若不加 `+1`，`malloc` 的内存不足以存储 `'\0'`，`strcpy` 会导致内存越界访问，引发不安全的行为或崩溃。

### **4.3.7 多个对象构造和析构**

#### **4.3.7.1 初始化列表**

构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。

初始化列表简单使用:

```cpp
class Person{
public:
#if 0
	//传统方式初始化
	Person(int a,int b,int c){
		mA = a;
		mB = b;
		mC = c;
	}
#endif
	//初始化列表方式初始化
	Person(int a, int b, int c):mA(a),mB(b),mC(c){}
	void PrintPerson(){
		cout << "mA:" << mA << endl;
		cout << "mB:" << mB << endl;
		cout << "mC:" << mC << endl;
	}
private:
	int mA;
	int mB;
	int mC;
};
```

**注意：**初始化成员列表(参数列表)只能在构造函数使用。

> 初始化列表是用来初始化成员变量和调用基类构造函数的。基类构造函数在继承哪里会讲。

#### **4.3.7.2 类对象作为成员**

在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做**对象成员**。

C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，c++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？

那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。

解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即构造函数初始化列表。

当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。

析构函数和构造函数调用顺序相反，先构造，后析构。

```cpp
//汽车类
class Car{
public:
    Car(){
        cout << "Car 默认构造函数!" << endl;
        mName = "大众汽车";
    }
    Car(string name){
        cout << "Car 带参数构造函数!" << endl;
        mName = name;
    }
    ~Car(){
        cout << "Car 析构函数!" << endl;
    }
public:
    string mName;
};

//拖拉机
class Tractor{
public:
    Tractor(){
        cout << "Tractor 默认构造函数!" << endl;
        mName = "爬土坡专用拖拉机";
    }
    Tractor(string name){
        cout << "Tractor 带参数构造函数!" << endl;
        mName = name;
    }
    ~Tractor(){
        cout << "Tractor 析构函数!" << endl;
    }
public:
    string mName;
};

//人类
class Person{
public:
//#if 1
    //类mCar不存在合适的构造函数
    Person(string name){
        mName = name;
    }
//#else
    //初始化列表可以指定调用构造函数
	Person(string carName, string tracName, string name) : mTractor(tracName), mName(name),mCar(carName){
		cout << "Person 构造函数!" << endl;
	}
//#endif

    void GoWorkByCar(){
        cout << mName << "开着" << mCar.mName << "去上班!" << endl;
    }
    void GoWorkByTractor(){
        cout << mName << "开着" << mTractor.mName << "去上班!" << endl;
    }
    ~Person(){
        cout << "Person 析构函数!" << endl;
    }
private:
    string mName;
    Car mCar;
    Tractor mTractor;
};

int main(){

    Person person("宝马", "东风拖拉机", "赵四");
//    Person person("刘能");
    person.GoWorkByCar();
    person.GoWorkByTractor();

}
```

输出结果：![2024-11-14_15-22-55.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/14/2024-11-14_15-22-55.png)

### **4.3.8 explicit关键字**

c++提供了关键字explicit，禁止通过构造函数进行的隐式转换。声明为explicit的构造函数不能在隐式转换中使用。

**[explicit注意]**

- explicit用于修饰构造函数,防止隐式转化。
- 是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。

```cpp
class MyString{
public:
	explicit MyString(int n){
		cout << "MyString(int n)!" << endl;
	}
	MyString(const char* str){
		cout << "MyString(const char* str)" << endl;
	}
};

int main(){

	//给字符串赋值？还是初始化？
	//MyString str1 = 1; //报错，int->MyString，类型转换说明这里是隐士转换
	MyString str2(10);

	//寓意非常明确，给字符串赋值
	MyString str3 = "abcd";//string->MyString,这里也是隐士转换
	MyString str4("abcd");

	return EXIT_SUCCESS;
}
```

### **4.3.9 动态对象创建**

当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。

所以动态的意思意味着不确定性。

为了解决这个普遍的编程问题，在运行中可以创建和销毁对象是最基本的要求。当然c早就提供了动态内存分配（dynamic memory allocation）,函数malloc和free可以在运行时从堆中分配存储单元。

然而这些函数在c++中不能很好的运行，因为它不能帮我们完成对象的初始化工作。

#### **4.3.9.1 对象创建**

当创建一个c++对象时会发生两件事:

1. 为对象分配内存
2. 调用构造函数来初始化那块内存

第一步我们能保证实现，需要我们确保第二步一定能发生。c++强迫我们这么做是因为使用未初始化的对象是程序出错的一个重要原因。

#### **4.3.9.2 C动态分配内存方法**

为了在运行时动态分配内存，c在他的标准库中提供了一些函数,malloc以及它的变种calloc和realloc,释放内存的free,这些函数是有效的、但是原始的，需要程序员理解和小心使用。为了使用c的动态内存分配函数在堆上创建一个类的实例，我们必须这样做:

```cpp
class Person{
public:
	Person(){
		mAge = 20;
		pName = (char*)malloc(strlen("john")+1);
		strcpy(pName, "john");
	}
	void Init(){
		mAge = 20;
		pName = (char*)malloc(strlen("john")+1);
		strcpy(pName, "john");
	}
	void Clean(){
		if (pName != NULL){
			free(pName);
		}
	}
public:
	int mAge;
	char* pName;
};
int main(){

	//分配内存
	Person* person = (Person*)malloc(sizeof(Person));
	if(person == NULL){
		return 0;
	}
	//调用初始化函数
	person->Init();
	//清理对象
	person->Clean();
	//释放person对象
	free(person);

	return EXIT_SUCCESS;
}
```

**问题：**

- 程序员必须确定对象的长度。
- malloc返回一个void*指针，c++不允许将void*赋值给其他任何指针，必须强转。

> `void*` 是一种指向未知类型的通用指针，允许在不同类型的数据之间进行指针传递。
>
> **不能将** `void*` 隐式地赋值给其他类型的指针，但可以通过显式类型转换来实现赋值。
>
> 它不能直接解引用，需要将其转换为实际的类型指针后才能访问数据。
>
> 适用于内存管理、泛型数据结构和回调函数等场景。

- malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。
- 用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。

> 使用 `malloc` 分配内存，`person` 只是一个指向内存的裸指针，并不会自动调用 `Person` 的构造函数。这意味着对象的成员变量可能没有被初始化，从而导致潜在的未定义行为。为了解决这个问题，通常需要手动调用 `Init()` 函数来初始化对象。

c的动态内存分配函数太复杂，容易令人混淆，是不可接受的，c++中我们推荐使用运算符new 和 delete.

#### **4.3.9.3 new operator**

C++中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。

```cpp
Person* person = new Person;
相当于:
Person* person = (Person*)malloc(sizeof(Person));
	if(person == NULL){
		return 0;
	}
person->Init();
```

New操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。

现在我们发现在堆里创建对象的过程变得简单了，只需要一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆创建一个对象和在栈里创建对象一样简单。

> 补充说明：对象名与对象的地址
>
> 在 C++ 中，对象名**不是直接等于对象的地址**，但可以看作是对象地址的一个隐式表示。具体含义如下：
>
> **1. 对象名的含义：**
>
> - 对象名本质上是一个标识符，用来引用内存中存储的具体对象。
> - 当你在代码中使用对象名时，编译器会根据上下文解析为对应的对象存储位置。
> - 如果是普通对象，`对象名`并不是存储对象地址的变量，而是直接代表该对象的实体。
>
> **2. 如何获取对象的地址：**
>
> - 使用取地址运算符 `&`：
>
>   ```cpp
>   Person obj;
>   Person* p = &obj;  // &obj 获取 obj 的地址
>   ```
>
> - 通过 `&obj` 可以明确获得对象的地址，赋值给指针或进一步操作。
>
> **3. 特殊情况：对象名和指针的关系：**
>
> - **普通对象**：
>   对于非指针类型的对象，`对象名`不是地址，`&对象名`才是地址。
>
>   ```cpp
>   Person obj;   // obj 是一个普通对象
>   &obj;         // 获取 obj 的地址
>   ```
>
> - **指针类型对象**：
>   如果对象本身是一个指针，那么对象名指向的是另一块内存的地址。
>
>   ```cpp
>   Person* obj = new Person();  // obj 是一个指针
>   obj;                         // 表示指针存储的地址
>   *obj;                        // 表示指针指向的对象
>   ```
>
> **总结：**
>
> - 普通对象名不是地址，而是对象的标识符（代表指向的实际对象内容）。
> - 可以通过 `&` 运算符获取对象的地址。
> - 对于指针类型的对象，`对象名`存储的是地址，`*对象名`代表指向的实际对象内容。
> - 图示：![2024-11-18_14-44-28.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/2024-11-18_14-44-28.png)![2024-11-18_14-42-18.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/2024-11-18_14-42-18.png)

#### **4.3.9.4 delete operator**

new表达式的反面是delete表达式。delete表达式先调用析构函数，然后释放内存。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。

delete只适用于由new创建的对象。

如果使用一个由malloc或者calloc或者realloc创建的对象使用delete,这个行为是未定义的。因为大多数new和delete的实现机制都使用了malloc和free,所以很可能没有调用析构函数就释放了内存。

> `delete` 可能不会调用析构函数：`delete` 运算符是为 `new` 运算符分配的内存设计的。它不仅释放内存，还会调用对象的析构函数进行清理工作。然而，`malloc` 或 `calloc` 分配的内存并没有构造函数和析构函数的管理。因此，使用 `delete` 时，析构函数可能根本不会被调用，导致资源未正确释放，可能引发内存泄漏、未定义行为或程序崩溃。
>
> **正确做法**
>
> - 如果使用 `new` 分配内存，则必须使用 `delete` 释放内存。
> - 如果使用 `malloc`、`calloc` 或 `realloc` 分配内存，则必须使用 `free` 释放内存。

如果正在删除的对象的指针是NULL,将不发生任何事，因此建议在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。

```cpp
class Person{
public:
	Person(){
		cout << "无参构造函数!" << endl;
		pName = (char*)malloc(strlen("undefined") + 1);
		strcpy(pName, "undefined");
		mAge = 0;
	}
	Person(char* name, int age){
		cout << "有参构造函数!" << endl;
		pName = (char*)malloc(strlen(name) + 1);
		strcpy(pName, name);
		mAge = age;
	}
	void ShowPerson(){
		cout << "Name:" << pName << " Age:" << mAge << endl;
	}
	~Person(){
		cout << "析构函数!" << endl;
		if (pName != NULL){
			free(pName);  // 使用 free 而不是 delete
			pName = NULL;
		}
	}
public:
	char* pName;
	int mAge;
};

void test(){
	Person* person1 = new Person;
	Person* person2 = new Person("John",33);

	person1->ShowPerson();
	person2->ShowPerson();

	delete person1;
	delete person2;
}
```

#### **4.3.9.5 用于数组的new和delete**

使用new和delete在堆上创建数组非常容易。

```cpp
//创建字符数组
char* pStr = new char[100];
//创建整型数组
int* pArr1 = new int[100]; 
//创建整型数组并初始化
int* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

//释放数组内存
delete[] pStr;
delete[] pArr1;
delete[] pArr2;
```

当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，除了在栈上可以聚合初始化，必须提供一个默认的构造函数。

```cpp
class Person{
public:
    Person(){
        pName = (char*)malloc(strlen("undefined") + 1);
        strcpy(pName, "undefined");
        mAge = 0;
    }
    Person(char* name, int age){
        pName = (char*)malloc(strlen(name) + 1);
        strcpy(pName, name);
        mAge = age;
    }
    ~Person(){
        if (pName != NULL){
            free(pName) ;
        }
    }
public:
    char* pName;
    int mAge;
};

void test(){
    //栈聚合初始化
    Person person[] = { Person("john", 20), Person("Smith", 22) };
    cout << person[1].pName << endl;
    //创建堆上对象数组必须提供构造函数
    Person* workers = new Person[20];
    delete[] workers;
}
```

#### **4.3.9.6 delete void\*可能会出错**

如果对一个void*指针执行delete操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数.以下代码未调用析构函数，导致可用内存减少。

```cpp
class Person{
public:
    Person(char* name, int age){
        pName = (char*)malloc(strlen(name) + 1);
        strcpy(pName,name);
        mAge = age;
    }
    ~Person(){
        if (pName != NULL){
            cout<<"ggggg"<<endl;
            free(pName);
        }
    }
public:
    char* pName;
    int mAge;
};

void test(){
    void* person = new Person("john",20);
    delete person;
}
```

#### **4.3.9.7 使用new和delete采用相同形式**

```cpp
Person* person = new Person[10];
delete person;
```

以上代码有什么问题吗？(vs下直接中断、qt下析构函数调用一次)

使用了new也搭配使用了delete，问题在于Person有10个对象，那么其他9个对象可能没有调用析构函数，也就是说其他9个对象可能删除不完全，因为它们的析构函数没有被调用。

我们现在清楚使用new的时候发生了两件事: 一、分配内存；二、调用构造函数，那么调用delete的时候也有两件事：一、析构函数；二、释放内存。

那么刚才我们那段代码最大的问题在于：person指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，person指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括"数组大小记录"，使得delete的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图:

![2024-11-11_15-20-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-20-09.png.png)

本图只是为了说明，编译器不一定如此实现，但是很多编译器是这样做的。

当我们使用一个delete的时候，我们必须让delete知道指针指向的内存空间中是否存在一个"数组大小记录"的办法就是我们告诉它。当我们使用delete[]，那么delete就知道是一个对象数组，从而清楚应该调用几次析构函数。

**结论:**

如果在new表达式中使用[]，必须在相应的delete表达式中也使用[].如果在new表达式中不使用[], 一定不要在相应的delete表达式中使用[].

### **4.3.10 静态成员**

在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。

不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。

#### **4.3.10.1 静态成员变量**

在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。

静态成员变量的内存是在程序加载阶段由运行时系统分配的，而不是在对象创建时分配，早于对象创建。

- **静态成员变量必须在类中声明，在类外定义****。**
- **静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。**
- **静态数据成员可以通过类名或者对象名来引用。**

```cpp
class Person{
public:
	//类的静态成员属性
	static int sNum;
private:
	static int sOther;
};

//类外初始化，初始化时不加static
int Person::sNum = 0;
int Person::sOther = 0;
int main(){

	//1. 通过类名直接访问
	Person::sNum = 100;
	cout << "Person::sNum:" << Person::sNum << endl;

	//2. 通过对象访问
	Person p1, p2;
	p1.sNum = 200;

	cout << "p1.sNum:" << p1.sNum << endl;
	cout << "p2.sNum:" << p2.sNum << endl;

	//3. 静态成员也有访问权限，类外不能访问私有成员
	//cout << "Person::sOther:" << Person::sOther << endl;
	Person p3;
	//cout << "p3.sOther:" << p3.sOther << endl;

	system("pause");
	return EXIT_SUCCESS;
}
```

#### **4.3.10.2 静态成员函数**

在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。

静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。

- 静态成员函数只能访问静态变量，不能访问普通成员变量
- 静态成员函数的使用和静态成员变量一样
- 静态成员函数也有访问权限
- 普通成员函数可访问静态成员变量、也可以访问非经常成员变量

```cpp
class Person{
public:
	//普通成员函数可以访问static和non-static成员属性
	void changeParam1(int param){
		mParam = param;
		sNum = param;
	}
	//静态成员函数只能访问static成员属性
	static void changeParam2(int param){
		//mParam = param; //无法访问
		sNum = param;
	}
private:
	static void changeParam3(int param){
		//mParam = param; //无法访问
		sNum = param;
	}
public:
	int mParam;
	static int sNum;
};

//静态成员属性类外初始化
int Person::sNum = 0;

int main(){

	//1. 类名直接调用
	Person::changeParam2(100);

	//2. 通过对象调用
	Person p;
	p.changeParam2(200);

	//3. 静态成员函数也有访问权限
	//Person::changeParam3(100); //类外无法访问私有静态成员函数
	//Person p1;
	//p1.changeParam3(200);
	return EXIT_SUCCESS;
}
```

#### **4.3.10.3 const静态成员属性**

如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。**定义静态const数据成员时，最好在类内部初始化（初始化=声明+定义，不加const静态成员变量必须在类中声明，在类外定义）**。

```cpp
class Person{
public:
	//static const int mShare = 10;
	const static int mShare = 10; //只读区，不可修改
};
int main(){

	cout << Person::mShare << endl;
	//Person::mShare = 20;

	return EXIT_SUCCESS;
}
```

#### **4.3.10.4 静态成员实现单例模式**

单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

![2024-11-11_15-21-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-21-09.png.jpeg)

Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。

示例：用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数。

```cpp
class Printer{
public:
	static Printer* getInstance(){ return pPrinter;}
	void PrintText(string text){
		cout << "打印内容:" << text << endl;
		cout << "已打印次数:" << mTimes << endl;
		cout << "--------------" << endl;
		mTimes++;
	}
private:
	Printer(){ mTimes = 0; }
	Printer(const Printer&){}
private:
	static Printer* pPrinter;
	int mTimes;
};

Printer* Printer::pPrinter = new Printer;

void test(){
	Printer* printer = Printer::getInstance();
	printer->PrintText("离职报告!");
	printer->PrintText("入职合同!");
	printer->PrintText("提交代码!");
}
```

## **4.4 C++面向对象模型初探**

### **4.4.1 成员变量和函数的存储**

在c语言中，"分开来声明的，也就是说，语言本身并没有支持"数据"和"函数"之间的关联性我们把这种程序方法称为"程序性的"，由一组"分布在各个以功能为导航的函数中"的算法驱动，它们处理的是共同的外部数据。

c++实现了"封装"，那么数据(成员属性)和操作(成员函数)是什么样的呢？

回答："数据"和"处理数据的操作(函数)"是分开存储的。

- c++中的**非静态数据成员（即非静态成员属性）**直接内含在类对象中，就像c struct一样。
- 成员函数(member function)虽然内含在class声明之内，却不出现在对象中。
- 每一个非内联成员函数(non-inline member function)只会诞生一份函数实例.

> **非内联成员函数**指的是那些没有使用 `inline` 关键字修饰的成员函数。默认情况下，C++ 中的成员函数如果没有显式声明为 `inline`，会按照常规的函数调用方式进行处理。
>
> **解释**
>
> 1. **非内联成员函数的调用方式**：
>    - 当你调用一个非内联成员函数时，编译器会生成代码来进行函数调用。这通常意味着，函数的参数会被压入栈中，程序会跳转到函数的代码位置，执行完后再返回。这种调用方式会有一定的开销。
> 2. **与内联成员函数的区别**：
>    - 与此相对，**内联成员函数**会在调用点直接插入函数体的代码，避免了上述的调用开销。内联函数通常用于短小的、频繁调用的函数。
> 3. **成员函数内联的限制**：
>    - 即使声明为 `inline`，如果函数太复杂（例如包含循环、递归等），编译器可能不会进行内联优化，仍然会生成常规的函数调用。
>    - 成员函数若是虚函数（`virtual`），也不能被内联，因为虚函数的调用是通过虚函数表进行的，这种调用方式不适合直接内联。
>
> **示例**
>
> ```cpp
> class MyClass {
> public:
>     // 非内联成员函数
>     int add(int a, int b) {
>         return a + b;
>     }
> 
>     // 内联成员函数
>     inline int multiply(int a, int b) {
>         return a * b;
>     }
> };
> ```
>
> 在这个例子中，`add` 是一个非内联成员函数，它会按照普通的函数调用机制执行；而 `multiply` 被声明为内联成员函数，编译器可能会将其代码直接嵌入到调用点。
>
> 总结来说，非内联成员函数是指没有使用 `inline` 关键字的成员函数，它们通过常规的函数调用方式执行，并且可能带来一定的性能开销。

```cpp
class MyClass01{
public:
	int mA;
};

class MyClass02{
public:
	int mA;
	static int sB;
};

class MyClass03{
public:
	void printMyClass(){
		cout << "hello world!" << endl;
	}
public:
	int mA;
	static int sB;
};

class MyClass04{
public:
	void printMyClass(){
		cout << "hello world!" << endl;
	}
	static void ShowMyClass(){
		cout << "hello world！" << endl;
	}
public:
	int mA;
	static int sB;
};

int main(){

	MyClass01 mclass01;
	MyClass02 mclass02;
	MyClass03 mclass03;
	MyClass04 mclass04;

	cout << "MyClass01:" << sizeof(mclass01) << endl; //4
	//静态数据成员并不保存在类对象中
	cout << "MyClass02:" << sizeof(mclass02) << endl; //4
	//非静态成员函数不保存在类对象中
	cout << "MyClass03:" << sizeof(mclass03) << endl; //4
	//静态成员函数也不保存在类对象中
	cout << "MyClass04:" << sizeof(mclass04) << endl; //4

	return EXIT_SUCCESS;
}
```

**通过上面的案例，我们可以的得出：C++类对象中的变量和函数是分开存储。**

### **4.4.2 this指针**

#### **4.4.2.1 this指针工作原理**

通过上例我们知道，c++的数据和操作也是分开存储，并且每一个非内联成员函数(non-inline member function)只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

![2024-11-11_15-22-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-22-09.png.png)

c++通过提供特殊的对象指针，this指针，解决上述问题。This指针指向被调用的成员函数所属的对象。

c++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为"指向本对象的指针"，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。

> `this` 指针只是一个指向当前对象的地址，它是在成员函数的执行期间由编译器隐式传递的，并不在对象实例中占有空间。它的存在是由编译器在调用成员函数时自动处理的。

this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，在外部看来，每一个对象都拥有自己的函数成员。一般情况下，并不写this，而是让系统进行默认设置。

this指针永远指向当前对象。

成员函数通过this指针即可知道操作的是那个对象的数据。This指针是一种隐含指针，它隐含于每个类的非静态成员函数中。This指针无需定义，直接使用即可。

注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。

**c++编译器对普通成员函数的内部处理** ![2024-11-11_15-23-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-23-09.png.png)**4.4.2.2 this指针的使用**

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this.

```cpp
class Person{
public:
    //1. 当形参名和成员变量名一样时，this指针可用来区分
    Person(string name,int age){
        //name = name;
        //age = age; //输出错误
        this->name = name;
        this->age = age;
    }
    //2. 返回对象本身的引用
    //重载赋值操作符
    //其实也是两个参数，其中隐藏了一个this指针
    Person PersonPlusPerson(Person& person){
        string newname = this->name + person.name;
        int newage = this->age + person.age;
        Person newperson(newname, newage);
        return newperson;
    }
    void ShowPerson(){
        cout << "Name:" << name << " Age:" << age << endl;
    }
public:
    string name;
    int age;
};

//3. 成员函数和全局函数(Perosn对象相加)
Person PersonPlusPerson(Person& p1,Person& p2){
    string newname = p1.name + p2.name;
    int newage = p1.age + p2.age;
    Person newperson(newname,newage);
    return newperson;
}

int main(){

    Person person("John",100);
    person.ShowPerson();

    cout << "---------" << endl;
    Person person1("John",20);
    Person person2("001", 10);
    //1.全局函数实现两个对象相加
    Person person3 = PersonPlusPerson(person1, person2);
    person1.ShowPerson();
    person2.ShowPerson();
    person3.ShowPerson();
    //2. 成员函数实现两个对象相加
    Person person4 = person1.PersonPlusPerson(person2);
    person4.ShowPerson();

    system("pause");
    return EXIT_SUCCESS;
}
```

#### **4.4.2.3 const修饰成员函数**

- 用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量，

- 当成员变量类型符前用mutable修饰时例外。

```cpp
//const修饰成员函数
class Person{
public:
	Person(){
		this->mAge = 0;
		this->mID = 0;
	}
	//在函数括号后面加上const,修饰成员变量不可修改,除了mutable变量
	void sonmeOperate() const{
		//this->mAge = 200; //mAge不可修改
		this->mID = 10;
	}
	void ShowPerson(){
		cout << "ID:" << mID << " mAge:" << mAge << endl;
	}
private:
	int mAge;
	mutable int mID;
};

int main(){

	Person person;
	person.sonmeOperate();
	person.ShowPerson();

	system("pause");
	return EXIT_SUCCESS;
}
```

#### **4.4.2.4 const修饰对象(常对象)**

- 常对象只能调用const的成员函数
- 常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰

```cpp
class Person{
public:
    Person(){
        this->mAge = 0;
        this->mID = 0;
    }
    void ChangePerson() const{
//        mAge = 100;//mAge不可修改
        mID = 100;
    }
    void ShowPerson(){
        this->mAge = 1000;
        cout << "ID:" << this->mID << " Age:" << this->mAge << endl;
    }

public:
    int mAge;
    mutable int mID;
};

void test(){
    const Person person;
    //1. 可访问数据成员
    cout << "Age:" << person.mAge << endl;
    //person.mAge = 300; //不可修改
    person.mID = 1001; //但是可以修改mutable修饰的成员变量
    //2. 只能访问const修饰的函数
    //person.ShowPerson();
    person.ChangePerson();
}
```

## **4.5 友元**

类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部(作用域之外)访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？

解决方法是使用友元函数，友元函数是一种特权函数，c++允许这个特权函数访问私有成员。这一点从现实生活中也可以很好的理解：

比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。

程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。

### **4.5.1 友元语法**

- friend关键字只出现在声明处
- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数不是类的成员，不带this指针
- 友元函数可访问对象任意成员属性，包括私有属性

```cpp
class Building;
//友元类
class MyFriend{
public:
	//友元成员函数
	void LookAtBedRoom(Building& building);
	void PlayInBedRoom(Building& building);
};
class Building{
	//全局函数做友元函数
	friend void CleanBedRoom(Building& building);
#if 0//相当于将下面的代码注释掉
	//成员函数做友元函数
	friend void MyFriend::LookAtBedRoom(Building& building);
	friend void MyFriend::PlayInBedRoom(Building& building);
#else	
	//友元类
	friend class MyFriend;
#endif
public:
	Building();
public:
	string mSittingRoom;
private:
	string mBedroom;
};

void MyFriend::LookAtBedRoom(Building& building){
	cout << "我的朋友参观" << building.mBedroom << endl;
}
void MyFriend::PlayInBedRoom(Building& building){
	cout << "我的朋友玩耍在" << building.mBedroom << endl;
}

//友元全局函数
void CleanBedRoom(Building& building){
	cout << "友元全局函数访问" << building.mBedroom << endl;
}

Building::Building(){
	this->mSittingRoom = "客厅";
	this->mBedroom = "卧室";
}

int main(){

	Building building;
	MyFriend myfriend;

	CleanBedRoom(building);
	myfriend.LookAtBedRoom(building);
	myfriend.PlayInBedRoom(building);

	system("pause");
	return EXIT_SUCCESS;
}
```

> **代码分解和解释：**
>
> **1. 类** `MyFriend` 和 类 `Building`
>
> ```cpp
> class Building;
> class MyFriend {
> public:
>     void LookAtBedRoom(Building& building);
>     void PlayInBedRoom(Building& building);
> };
> ```
>
> - `class Building;` 是对`Building`类的前向声明，使得 `MyFriend` 可以声明一个使用 `Building&` 类型的参数。
> - `MyFriend`类中声明了两个公共成员函数 `LookAtBedRoom` 和 `PlayInBedRoom`。这两个函数的参数是 `Building&`，目的是访问`Building`的私有成员 `mBedroom`。
>
> **2.** `Building`类
>
> ```cpp
> class Building {
>     friend void CleanBedRoom(Building& building); // 友元全局函数声明
> #if 0
>     friend void MyFriend::LookAtBedRoom(Building& building);
>     friend void MyFriend::PlayInBedRoom(Building& building);
> #else
>     friend class MyFriend; // 将MyFriend类作为友元类
> #endif
> public:
>     Building();
> public:
>     string mSittingRoom;
> private:
>     string mBedroom;
> };
> ```
>
> - **成员变量**：
>   - `mSittingRoom`：公有成员，表示客厅，可以直接被外部访问。
>   - `mBedroom`：私有成员，表示卧室，不能被非友元直接访问。
> - **友元声明**：
>   - `friend void CleanBedRoom(Building& building);` 声明了一个友元全局函数 `CleanBedRoom`，使它能够访问 `Building`的私有成员 `mBedroom`。
>   - `#if 0` 预处理指令使 `MyFriend`类的成员函数`LookAtBedRoom`和`PlayInBedRoom`作为友元函数的代码被注释掉。
>   - `friend class MyFriend;` 声明`MyFriend`为`Building`的友元类。这样，`MyFriend`类中的任何成员函数都可以访问 `Building`的私有成员 `mBedroom`。
>
> **3. 友元成员函数实现**
>
> ```cpp
> void MyFriend::LookAtBedRoom(Building& building) {
>     cout << "我的朋友参观" << building.mBedroom << endl;
> }
> 
> void MyFriend::PlayInBedRoom(Building& building) {
>     cout << "我的朋友玩耍在" << building.mBedroom << endl;
> }
> ```
>
> - `LookAtBedRoom` 和 `PlayInBedRoom` 是 `MyFriend` 类的成员函数。
> - 由于 `MyFriend` 是 `Building` 的友元类，这两个成员函数可以访问 `Building` 的私有成员 `mBedroom`。
>
> **4. 友元全局函数实现**
>
> ```cpp
> void CleanBedRoom(Building& building) {
>     cout << "友元全局函数访问" << building.mBedroom << endl;
> }
> ```
>
> - `CleanBedRoom` 是一个普通的全局函数，但由于在 `Building` 类中被声明为友元，因此可以访问 `Building` 的私有成员 `mBedroom`。
>
> **5.** `Building` 构造函数实现
>
> ```cpp
> Building::Building() {
>     this->mSittingRoom = "客厅";
>     this->mBedroom = "卧室";
> }
> ```
>
> - 构造函数对 `Building` 的成员变量进行了初始化，`mSittingRoom` 初始化为“客厅”，`mBedroom` 初始化为“卧室”。
>
> **6. 主函数**
>
> ```cpp
> int main() {
>     Building building;
>     MyFriend myfriend;
> 
>     CleanBedRoom(building);         // 友元全局函数调用
>     myfriend.LookAtBedRoom(building); // 友元类的成员函数调用
>     myfriend.PlayInBedRoom(building); // 友元类的成员函数调用
> 
>     system("pause");
>     return EXIT_SUCCESS;
> }
> ```
>
> - **创建对象**：`Building building;` 创建 `Building` 类对象，`MyFriend myfriend;` 创建 `MyFriend` 类对象。
> - **调用友元函数和友元类的成员函数**：
>   - `CleanBedRoom(building);` 调用全局友元函数 `CleanBedRoom`，访问并打印 `mBedroom` 的内容。
>   - `myfriend.LookAtBedRoom(building);` 调用 `MyFriend` 的成员函数 `LookAtBedRoom`，访问并打印 `mBedroom` 的内容。
>   - `myfriend.PlayInBedRoom(building);` 调用 `MyFriend` 的成员函数 `PlayInBedRoom`，访问并打印 `mBedroom` 的内容。
>
> **代码输出**
>
> 最终输出会是：
>
> ```cpp
> 友元全局函数访问卧室
> 我的朋友参观卧室
> 我的朋友玩耍在卧室
> ```
>
> **总结**
>
> 1. **友元全局函数** `CleanBedRoom` 可以访问 `Building` 类的私有成员 `mBedroom`。
> 2. **友元类** `MyFriend` 的成员函数 `LookAtBedRoom` 和 `PlayInBedRoom` 也可以访问 `mBedroom`，因为 `MyFriend` 是 `Building` 的友元类。
> 3. 友元机制允许特定函数或类访问类的私有成员，帮助实现特定的功能或需求。

**[友元类注意]**

- 友元关系不能被继承。
- 友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。
- 友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。

**思考: c++是纯面向对象的吗？**

如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。c++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟c++设计的目的是为了实用性，而不是追求理想的抽象。 --- Thinking in C++

### **4.5.2 课堂练习**

请编写电视机类，电视机有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视机只能逐一调整频道，不能指定频道，增加遥控类，遥控类除了拥有电视机已有的功能，再增加根据输入调台功能。

**提示：**遥控器可作为电视机类的友元类。

```cpp
class Remote;

class Television{
	friend class Remote;
public:
	enum{ On,Off }; //电视状态
	enum{ minVol,maxVol = 100 }; //音量从0到100
	enum{ minChannel = 1,maxChannel = 255 }; //频道从1到255
	Television(){
		mState = Off;
		mVolume = minVol;
		mChannel = minChannel;
	}

	//打开电视机
	void OnOrOff(){
		this->mState = (this->mState == On ? Off : On);
	}
	//调高音量
	void VolumeUp(){
		if (this->mVolume >= maxVol){
			return;
		}
		this->mVolume++;
	}
	//调低音量
	void VolumeDown(){
		if (this->mVolume <= minVol){
			return;
		}
		this->mVolume--;
	}
	//更换电视频道
	void ChannelUp(){
		if (this->mChannel >= maxChannel){
			return;
		}
		this->mChannel++;
	}
	void ChannelDown(){
		if (this->mChannel <= minChannel){
			return;
		}
		this->mChannel--;
	}
	//展示当前电视状态信息
	void ShowTeleState(){
		cout << "开机状态:" << (mState == On ? "已开机" : "已关机") << endl;
		if (mState == On){
			cout << "当前音量:" << mVolume << endl;
			cout << "当前频道:" << mChannel << endl;
		}
		cout << "-------------" << endl;
	}
private:
	int mState; //电视状态，开机，还是关机
	int mVolume; //电视机音量
	int mChannel; //电视频道
};

//电视机调台只能一个一个的调，遥控可以指定频道
//电视遥控器
class Remote{
public:
	Remote(Television* television){
		pTelevision = television;
	}
public:
	void OnOrOff(){
		pTelevision->OnOrOff();
	}
	//调高音量
	void VolumeUp(){
		pTelevision->VolumeUp();
	}
	//调低音量
	void VolumeDown(){
		pTelevision->VolumeDown();
	}
	//更换电视频道
	void ChannelUp(){
		pTelevision->ChannelUp();
	}
	void ChannelDown(){
		pTelevision->ChannelDown();
	}
	//设置频道 遥控新增功能
	void SetChannel(int channel){
		if (channel < Television::minChannel || channel > Television::maxChannel){
			return;
		}
		pTelevision->mChannel = channel;
	}

	//显示电视当前信息
	void ShowTeleState(){
		pTelevision->ShowTeleState();
	}
private:
	Television* pTelevision;
};


//直接操作电视
void test01(){

	Television television;
	television.ShowTeleState();
	television.OnOrOff(); //开机
	television.VolumeUp(); //增加音量+1
	television.VolumeUp(); //增加音量+1
	television.VolumeUp(); //增加音量+1
	television.VolumeUp(); //增加音量+1
	television.ChannelUp(); //频道+1
	television.ChannelUp(); //频道+1
	television.ShowTeleState();
}

//通过遥控操作电视
void test02(){
	//创建电视
	Television television;
	//创建遥控
	Remote remote(&television);
	remote.OnOrOff();
	remote.ChannelUp();//频道+1
	remote.ChannelUp();//频道+1
	remote.ChannelUp();//频道+1
	remote.VolumeUp();//音量+1
	remote.VolumeUp();//音量+1
	remote.VolumeUp();//音量+1
	remote.VolumeUp();//音量+1
	remote.ShowTeleState();
}
```

> 细节：
>
> ```cpp
> enum{ On,Off }; //电视状态
> enum{ minVol,maxVol = 100 }; //音量从0到100
> enum{ minChannel = 1,maxChannel = 255 }; //频道从1到255
> ```
>
> 这里enum使用了匿名的形式（即，匿名枚举）；
>
> 如果使用显示的可以这样写：`enum TelevisionState { On, Off };`
>
> 这样，你就可以通过 `TelevisionState::On` 或 `TelevisionState::Off` 来引用枚举值

## **4.5 强化训练(数组类封装)**

**MyArray.h**

```cpp
#ifndef MYARRAY_H
#define MYARRAY_H

class MyArray{
public:
	//无参构造函数，用户没有指定容量，则初始化为100
	MyArray();
	//有参构造函数，用户指定容量初始化
	explicit MyArray(int capacity);
	//用户操作接口
	//根据位置添加元素
	void SetData(int pos, int val);
	//获得指定位置数据
	int GetData(int pos);
	//尾插法
	void PushBack(int val);
	//获得长度
	int GetLength();
	//析构函数，释放数组空间
	~MyArray();
private:
	int mCapacity; //数组一共可容纳多少个元素
	int mSize; //当前有多少个元素
	int* pAdress; //指向存储数据的空间
};

#endif
```

**MyArray.cpp**

```cpp
#include"MyArray.h"

MyArray::MyArray(){
	this->mCapacity = 100;
	this->mSize = 0;
	//在堆开辟空间
	this->pAdress = new int[this->mCapacity];
}
//有参构造函数，用户指定容量初始化
MyArray::MyArray(int capacity){
	this->mCapacity = capacity;
	this->mSize = 0;
	//在堆开辟空间
	this->pAdress = new int[capacity];
}
//根据位置添加元素
void MyArray::SetData(int pos, int val){
	if (pos < 0 || pos > mCapacity - 1){
		return;
	}
	pAdress[pos] = val;
}
//获得指定位置数据
int MyArray::GetData(int pos){
	return pAdress[pos];
}
//尾插法
void MyArray::PushBack(int val){
	if (mSize >= mCapacity){
		return;
	}
	this->pAdress[mSize] = val;
	this->mSize++;
}
//获得长度
int MyArray::GetLength(){
	return this->mSize;
}
//析构函数，释放数组空间
MyArray::~MyArray(){
	if (this->pAdress != nullptr){
		delete[] this->pAdress;
	}
}
```

**TestMyArray.cpp**

```cpp
#include"MyArray.h"

void test(){
	//创建数组
	MyArray myarray(50);
	//数组中插入元素
	for (int i = 0; i < 50; i++){
		//尾插法
		myarray.PushBack(i);
		//myarray.SetData(i, i);
	}
	//打印数组中元素
	for (int i = 0; i < myarray.GetLength(); i++){
		cout << myarray.GetData(i) << " ";
	}
	cout << endl;
}
```

> 4.5 强化训练主要说明了分多个文件的程序标准写法。

## **4.6 运算符重载**

### **4.6.1 运算符重载基本概念**

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

**运算符重载(operator overloading)只是一种"语法上的方便",也就是它只是另一种函数调用的方式。**

在c++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。

**语法：**

定义重载的运算符就像定义函数，只是该函数的名字是operator@,这里的@代表了被重载的运算符。函数的参数中参数个数取决于两个因素。

- 运算符是一元(一个参数)的还是二元(两个参数)；
- 运算符被定义为全局函数(对于一元是一个参数，对于二元是两个参数)还是成员函数(对于一元没有参数，对于二元是一个参数-此时该类的对象用作左耳参数)

> | **属性**               | **成员函数**     | **全局函数**             |
> | ---------------------- | ---------------- | ------------------------ |
> | 左操作数               | 必须是当前类对象 | 可以是任意类型           |
> | 隐式 `this` 指针       | 有               | 没有                     |
> | 是否需要 `friend` 声明 | 不需要           | 需要（若访问私有成员）   |
> | 适用场景               | 左操作数是类对象 | 左右操作数可以是不同类型 |

**[两个极端]**

有些人很容易滥用运算符重载。它确实是一个有趣的工具。但是应该注意，它仅仅是一种语法上的方便而已，是另外一种函数调用的方式。从这个角度来看，只有在能使涉及类的代码更易写，尤其是更易读时(请记住，读代码的机会比我们写代码多多了)才有理由重载运算符。如果不是这样，就改用其他更易用，更易读的方式。

对于运算符重载，另外一个常见的反应是恐慌：突然之间，C运算符的含义变得不同寻常了，一切都变了，所有C代码的功能都要改变！并非如此，对于内置数据类型而言，其所有运算符的行为都是固定的，不可能被修改或重定义。

```cpp
class Complex {
private:
    double real;  // 实部
    double imag;  // 虚部

public:
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} // 构造函数

    Complex operator+(const Complex& other) {  // 重载加法运算符
        return Complex(real + other.real, imag + other.imag);
    }

    void print() const {  // 输出复数
        std::cout << real << " + " << imag << "i" << std::endl;
    }
};

int main() {
    Complex c1(1.2, 3.4);  // 创建复数 c1
    Complex c2(5.6, 7.8);  // 创建复数 c2

    Complex c3 = c1 + c2;  // 使用重载的加法运算符

    std::cout << "c1 + c2 = ";
    c3.print();  // 输出结果
}
```

> 细节：
>
> ```cpp
> Complex operator+(const Complex& other) {
>     return Complex(real + other.real, imag + other.imag);
> }
> ```
>
> 方法中为什么可以直接访问外部传来的Complex类实例的私有成员属性?
>
> 回答：由于 `operator+` 是 `Complex` 类的成员函数，它可以直接访问当前对象的私有成员（如 `real` 和 `imag`），同时也可以访问传入对象 `other` 的私有成员。这是 C++ 类的封装和成员函数的访问规则的正常行为。

### **4.6.2 运算符重载碰上友元函数**

友元函数可以是一个全局函数，友元函数可以访问某个类私有数据，因此，如果重载的运算符逻辑需要直接操作私有成员且想为全局函数，使用友元是最简洁的方式。

**案例: 重载左移操作符(<<),使得cout可以输出对象**。

```cpp
class Person{
	friend ostream& operator<<(ostream& os, Person& person);
public:
	Person(int id,int age){
		mID = id;
		mAge = age;
	}
private:
	int mID;
	int mAge;
};

ostream& operator<<(ostream& os, Person& person){
	os << "ID:" << person.mID << " Age:" << person.mAge;
	return os;
}

int main(){

	Person person(1001, 30);
	//cout << person; //cout.operator+(person)
	cout << person << " | " << endl;

	return EXIT_SUCCESS;
}
```

### **4.6.3 可重载的运算符**

几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意。

![2024-11-11_15-24-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-24-09.png.png)

### **4.6.4 自增自减(++/--)运算符重载**

重载的++和--运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int).

```cpp
class Complex{
    friend ostream& operator<<(ostream& os,Complex& complex){
        os << "A:" << complex.mA << " B:" << complex.mB << endl;
        return os;
    }
public:
    Complex(){
        mA = 0;
        mB = 0;
    }
    //重载前置++
    Complex& operator++(){
        mA++;
        mB++;
        return *this;
    }
    //重载后置++
    Complex operator++(int){
        Complex temp;
        temp.mA = this->mA;
        temp.mB = this->mB;
        mA++;
        mB++;
        return temp;
    }
    //前置--
    Complex& operator--(){
        mA--;
        mB--;
        return *this;
    }
    //后置--
    Complex operator--(int){
        Complex temp;
        temp.mA = mA;
        temp.mB = mB;
        mA--;
        mB--;
        return temp;
    }
    void ShowComplex(){
        cout << "A:" << mA << " B:" << mB << endl;
    }
private:
    int mA;
    int mB;
};

int main(){

    Complex complex;
    complex++;
    cout << complex;
    ++complex;
    cout << complex;

    Complex ret = complex++;//使用了拷贝构造函数
    cout << ret;
    cout << complex;

    cout << "------" << endl;
    ret--;
    --ret;
    cout << "ret:" << ret;
    complex--;
    --complex;
    cout << "complex:" << complex;
}
```

> 细节：
>
> ```cpp
>  friend ostream& operator<<(ostream& os,Complex& complex){
>         os << "A:" << complex.mA << " B:" << complex.mB << endl;
>         return os;
>     }
> ```
>
> **（1）**为什么上述方法可以在类内部定义？
>
> 回答：
>
> - 使用了friend 的**友元函数** 并不是类的成员函数，而是 **类外部的函数**，但是它被授予了对该类私有成员的访问权限。
> - **友元函数**它在类内部声明，但实际的定义通常会在类外部进行（不过你也可以在类内实现它，如在这个例子中）。
>
> **（2）**重载后置运算符时Complex operator++(int)，为什么加占位符int
>
> 回答：C++ 语言规定，当重载后置运算符时，必须接受一个 `int` 参数。这个参数并不影响操作的逻辑，它只是为了区分前置和后置运算符。C++ 中设计这种规则是为了确保用户能够清晰地区分前置和后置的行为，而不至于发生混淆。
>
> **（3）**重载前、后置运算符的返回值类型为什么不一样？
>
> 回答：首先回顾一下函数中的引用包含两个注意点：
>
> - 不能返回局部变量的引用。
> - 函数当左值，必须返回引用。
>
> ```cpp
> //重载前置++
> Complex& operator++(){
>     mA++;
>     mB++;
>     return *this;
> }
> ```
>
> 可知重载前置运算符时不存在返回局部变量的情况，而且重载前置运算符当左值使用引用使得可以链式调用（如++x++），所以应该使用引用形式的返回值。
>
> ```cpp
> //重载后置++
> Complex operator++(int){
>     Complex temp;
>     temp.mA = this->mA;
>     temp.mB = this->mB;
>     mA++;
>     mB++;
>     return temp;
> }
> ```
>
> 可知重载后置运算符时返回了局部变量temp，且重载后置运算符不当左值，所以不能使用引用形式的返回值。

> **优先使用++和--的标准形式，优先调用前置++。**
>
> 如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载operator++和operator--时应该模仿他们对应的内置操作符。
>
> 对于++和--而言，后置形式是先返回，然后对象++或者--，返回的是对象的原值。前置形式，对象先++或--，返回当前对象，返回的是新对象。其标准形式为:![2024-11-11_15-25-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-25-09.png.png) 调用代码时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。

### **4.6.5 指针运算符(\*、->)重载**

```cpp
class Person{
public:
    Person(int param){
        this->mParam = param;
    }
    void PrintPerson(){
        cout << "Param:" << mParam << endl;
    }
private:
    int mParam;
};

class SmartPointer{
public:
    SmartPointer(Person* person){
        this->pPerson = person;
    }
    //重载指针的->、*操作符
    Person* operator->(){
        return pPerson;
    }
    Person& operator*(){
        return *pPerson;
    }
    ~SmartPointer(){
        if (pPerson != NULL){
            delete pPerson;
        }
    }
public:
    Person* pPerson;
};

void test01(){


}
int main(){
    Person* person = new Person(100);
    //如果忘记释放，那么就会造成内存泄漏

    SmartPointer pointer(new Person(100));
    /*
    一旦重载的 operator->() 返回一个指针，该指针就会继续自动地使用 -> 访问其自身的成员函数或成员变量。
     这是一种递归的行为。换句话说，编译器会自动沿着链式调用进行展开。
    */
    pointer->PrintPerson();
    (*pointer).PrintPerson();  // 输出 Param: 100
}
```

> 细节：
>
> 1.new Person(100)返回一个地址。
>
> 2.为什么只写一个->就行了，而不写成pointer->->PrintPerson()，毕竟pointer->返回一个指针，指针想要调用成员函数需要再使用一个->形式才行？
>
> 解答：
>
> 这是因为`pointer->PrintPerson()`的写法是依赖于运算符重载的行为，重载的`->`运算符本身已经使得这种调用行为具备了指针的访问特性。我们不需要写成`pointer->->PrintPerson()`，原因如下：
>
> **解释**
>
> 1. **重载** `->` 的行为：
>    - 当你编写 `pointer->PrintPerson()` 时，实际上调用的是 `SmartPointer` 类中重载的 `operator->()` 方法，这个方法返回了 `pPerson` 指针（即 `Person*` 类型的指针）。
>    - 一旦重载的 `operator->()` 返回一个指针，该指针就会继续自动地使用 `->` 访问其自身的成员函数或成员变量。这是一种递归的行为。换句话说，编译器会自动沿着链式调用进行展开。
> 2. **链式调用的机制**：
>    - 当 `pointer->` 触发 `operator->()` 的重载，它会返回一个普通指针（即 `Person*`）。
>    - 然后，编译器会自动再次应用 `->` 操作符，使你可以直接调用 `pPerson` 所指向的 `Person` 对象的成员函数 `PrintPerson()`，无需手动再添加额外的 `->`。
>
> **直观示例**
>
> - `pointer->PrintPerson()` 等效于两步：
>   - 调用 `SmartPointer` 的 `operator->()`，返回 `pPerson`。
>   - 对 `pPerson` 再调用 `->PrintPerson()`，编译器会隐式处理这个访问过程。
>
> **为什么不需要写** `pointer->->PrintPerson()`？
>
> - 编译器的设计会自动“解包”这类重载运算符的结果，且这种行为符合用户直觉和通常的智能指针使用方式。只要 `operator->()` 返回的类型支持 `->` 操作，编译器会继续调用，不需要显式地使用两次 `->`。
> - 如果写成 `pointer->->PrintPerson()`，则多了不必要的操作，且会被视为语法错误，因为 `pointer->` 已经完成了返回普通指针的过程，编译器不会接受重复操作。
>
> 因此，`pointer->PrintPerson()` 已经足够实现功能，省去了手动的二次 `->` 使用。

### **4.6.6 赋值(=)运算符重载**

赋值符常常初学者的混淆。这是毫无疑问的，因为'='在编程中是最基本的运算符，可以进行赋值操作，也能引起拷贝构造函数的调用。

```cpp
class Person{
	friend ostream& operator<<(ostream& os,const Person& person){
		os << "ID:" << person.mID << " Age:" << person.mAge << endl;
		return os;
	}
public:
	Person(int id,int age){
		this->mID = id;
		this->mAge = age;
	}
	//重载赋值运算符
	Person& operator=(const Person& person){
		this->mID = person.mID;
		this->mAge = person.mAge;
		return *this;
	}
private:
	int mID;
	int mAge;
};

//1. =号混淆的地方
void test01(){
	Person person1(10, 20);
	Person person2 = person1; //调用拷贝构造
	//如果一个对象还没有被创建，则必须初始化，也就是调用构造函数
	//上述例子由于person2还没有初始化，所以会调用构造函数
	//由于person2是从已有的person1来创建的，所以只有一个选择
	//就是调用拷贝构造函数
	person2 = person1; //调用operator=函数
	//由于person2已经创建，不需要再调用构造函数，这时候调用的是重载的赋值运算符
}
//2. 赋值重载案例
void test02(){
	Person person1(20, 20);
	Person person2(30, 30);
	cout << "person1:" << person1;
	cout << "person2:" << person2;
	person2 = person1;
	cout << "person2:" << person2;
}
//常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了，解释如说明部分。
//对于本例来讲，无论如何执行这些赋值运算都是无害的，但如果对类的实现进行修改，那么将会出现差异；
//3. 类中指针
class Person2{
	friend ostream& operator<<(ostream& os, const Person2& person){
		os << "Name:" << person.pName << " ID:" << person.mID << " Age:" << person.mAge << endl;
		return os;
	}
public:
	Person2(char* name,int id, int age){
		this->pName = new char[strlen(name) + 1];
		strcpy(this->pName, name);
		this->mID = id;
		this->mAge = age;
	}
#if 1
	//重载赋值运算符
	Person2& operator=(const Person2& person){

		//注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存
		//这个时候如果直接赋值，会导致内存没有及时释放
		if (this->pName != NULL){
			delete[] this->pName;
		}

		this->pName = new char[strlen(person.pName) + 1];
		strcpy(this->pName,person.pName);
		this->mID = person.mID;
		this->mAge = person.mAge;
		return *this;
	}
#endif
	//析构函数
	~Person2(){
		if (this->pName != NULL){
			delete[] this->pName;
		}
	}
private:
	char* pName;
	int mID;
	int mAge;
};

void test03(){
	Person2 person1("John",20, 20);
	Person2 person2("Edward",30, 30);
	cout << "person1:" << person1;
	cout << "person2:" << person2;
	person2 = person1;
	cout << "person2:" << person2;
}
```

> 细节：
>
> **1.默认拷贝构造和赋值运算符的区别**
>
> 1. **拷贝构造函数**：在用一个对象初始化另一个对象时（如 `Person p2 = p1`），默认拷贝构造函数会创建一个新对象，并逐一拷贝成员。
> 2. **赋值运算符**：在对象已经存在的情况下，用一个对象的值替换另一个对象的值（如 `p2 = p1`），赋值运算符负责成员的赋值。
>
> **2.返回对象的引用是为了实现链式反应如：a=b=c。**
>
> **3.当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了，如何理解？**
>
> 当准备给两个对象赋值时，需要检查对象是否对自身赋值，是为了避免**自赋值**（self-assignment）可能引发的问题。自赋值指的是一个对象试图将自身的值赋给自己，例如 `obj = obj`。
>
> **为什么要检查自赋值？**
>
> 1. **资源管理问题**
>    如果类包含动态分配的资源（如指针），默认的赋值运算符不会处理这些资源的释放或分配。如果在赋值时没有检查是否是同一个对象，自赋值可能会导致资源的重复释放、悬垂指针等问题。
>
>    **示例：**
>
>    ```cpp
>    class MyClass {
>    public:
>        int* ptr;
>       
>        MyClass(int val) { ptr = new int(val); }
>        ~MyClass() { delete ptr; }
>       
>        MyClass& operator=(const MyClass& other) {
>            delete ptr;             // 释放原有资源
>            ptr = new int(*other.ptr); // 分配新资源
>            return *this;
>        }
>    };
>       
>    int main() {
>        MyClass obj(10);
>        obj = obj;  // 自赋值，delete ptr 会释放当前对象的资源
>        return 0;   // 程序崩溃，ptr 指向已释放的内存
>    }
>    ```
>
>    在上例中，`obj = obj` 的过程中：
>
>    - `delete ptr` 会释放自身的资源。
>    - `*other.ptr` 访问的是已经被释放的内存，导致未定义行为。
>
> 2. **性能优化**
>    即使类没有动态资源，自赋值通常是无意义的操作。跳过冗余的赋值可以提高性能，避免不必要的开销。
>
> **如何检查自赋值？**
>
> 在赋值运算符中，可以通过**检查赋值对象与当前对象的地址是否相同**来判断是否是自赋值：
>
> **实现：**
>
> ```cpp
> MyClass& operator=(const MyClass& other) {
>     if (this == &other) {
>         return *this;  // 如果是自赋值，直接返回自身
>     }
> 
>     // 否则正常处理赋值逻辑
>     delete ptr;                
>     ptr = new int(*other.ptr); 
>     return *this;
> }
> ```
>
> **解释：**
>
> 1. `this` 是当前对象的指针，`&other` 是右值对象的地址。
> 2. 如果 `this == &other`，表示当前对象和右值对象是同一个实例，直接返回自身，避免重复操作。
>
> **检查自赋值的实际作用**
>
> 1. **保护动态资源**
>    确保动态资源的安全管理，不因重复释放或重复分配导致问题。
> 2. **避免冗余操作**
>    通过检查自赋值跳过赋值逻辑，可以避免不必要的处理，提高程序效率。
> 3. **确保赋值逻辑正确**
>    如果没有检查自赋值，某些复杂赋值逻辑可能会意外破坏对象的状态。
>
> **总结**
>
> “检查是否是对自身赋值”的核心目的是避免自赋值带来的潜在问题，特别是在动态资源管理中：
>
> - **保护资源安全**：防止资源被重复释放或未正确分配。
> - **提升性能**：避免不必要的计算开销。
> - **增强代码的健壮性**：减少因赋值逻辑错误导致的潜在问题。
>
> 显式地检查 `if (this == &other)` 是在赋值运算符中一个良好的实践。

如果没有重载赋值运算符，编译器会自动创建默认的赋值运算符重载函数。行为类似默认拷贝构造，进行简单值拷贝。

### **4.6.7 等于和不等于(==、!=)运算符重载**

```cpp
class Complex{
public:
	Complex(char* name,int id,int age){
		this->pName = new char[strlen(name) + 1];
		strcpy(this->pName, name);
		this->mID = id;
		this->mAge = age;
	}
	//重载==号操作符
	bool operator==(const Complex& complex){
		if (strcmp(this->pName,complex.pName) == 0 && 
		    this->mID == complex.mID && 
			this->mAge == complex.mAge){
			return true;
		}
		return false;
	}
	//重载!=操作符
	bool operator!=(const Complex& complex){
		if (strcmp(this->pName, complex.pName) != 0 || 
		    this->mID != complex.mID || 
			this->mAge != complex.mAge){
			return true;
		}
		return false;
	}
	~Complex(){
		if (this->pName != NULL){
			delete[] this->pName;
		}
	}
private:
	char* pName;
	int mID;
	int mAge;
};
void test(){
	Complex complex1("aaa", 10, 20);
	Complex complex2("bbb", 10, 20);
	if (complex1 == complex2){ cout << "相等!" << endl; }
	if (complex1 != complex2){ cout << "不相等!" << endl; }
}
```

### **4.6.8 函数调用符号()重载**

```cpp
class Complex{
public:
	int Add(int x,int y){
		return x + y;
	}
	int operator()(int x,int y){
		return x + y;
	}
};
void test01(){
	Complex complex;
	cout << complex.Add(10,20) << endl;
	//对象当做函数来调用
	cout << complex(10, 20) << endl;
}
```

### **4.6.9 不要重载&&、||**

不能重载operator&& 和 operator|| 的原因是，无法在这两种情况下实现内置操作符的完整语义。说得更具体一些，内置版本特殊之处在于：内置版本的&&和||首先计算左边的表达式，如果这完全能够决定结果，就无需计算右边的表达式了--而且能够保证不需要。我们都已经习惯这种方便的特性了。

我们说操作符重载其实是另一种形式的函数调用而已，对于函数调用总是在函数执行之前对所有参数进行求值。

```cpp
class Complex{
public:
	Complex(int flag){
		this->flag = flag;
	}
	Complex& operator+=(Complex& complex){
		this->flag = this->flag + complex.flag;
		return *this;
	}
	bool operator&&(Complex& complex){
		return this->flag && complex.flag;
	}
public:
	int flag;
};
int main(){

	Complex complex1(0);  //flag 0 
	Complex complex2(1);  //flag 1

	//原来情况，应该从左往右运算，左边为假，则退出运算，结果为假
	//这边却是，先运算（complex1+complex2），导致，complex1的flag变为complex1+complex2的值， complex1.a = 1
	// 1 && 1
	//complex1.operator&&(complex1.operator+=(complex2))
	if (complex1 && (complex1 += complex2)){   //对于函数调用总是在函数执行之前对所有参数进行求值
		cout << "真!" << endl;
	}
	else{
		cout << "假!" << endl;
	}

	return EXIT_SUCCESS;
}
```

根据内置&&的执行顺序，我们发现这个案例中执行顺序并不是从左向右，而是先右后左，这就是不满足我们习惯的特性了。由于complex1 **+=** complex2先执行，导致complex1 本身发生了变化，初始值是0，现在经过+=运算变成1,1 && 1输出了真。

> - **重载的限制**：重载的 `&&` 和 `||` 无法保留短路特性，C++ 不允许通过重载改变内置逻辑运算符的执行顺序。所有子表达式都会被评估，可能导致性能下降或逻辑错误。
> - 推荐定义自定义函数或重载 `&` 和 `|`，以实现类似功能，同时保持逻辑的明确性和可控性。

### **4.6.10 符号重载总结**

- **=**, **[]**, **()** 和 **->** 操作符只能通过成员函数进行重载
- **<<** 和 **>>**只能通过全局函数配合友元函数进行重载
- 不要重载 **&&** 和 **||** 操作符，因为无法实现短路规则

常规建议

![2024-11-11_15-26-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-26-09.png.png)

### **4.6.11 强化训练_字符串类封装**

**MyString.h**

```cpp
#define _CRT_SECURE_NO_WARNINGS
#pragma once
#include <iostream>
using namespace std;

class MyString
{
	friend ostream& operator<< (ostream& out, MyString& str);
	friend istream& operator>>(istream& in, MyString& str);

public:
	MyString(const char *);
	MyString(const MyString&);
	~MyString();

	char& operator[](int index); //[]重载

	//=号重载
	MyString& operator=(const char * str);
	MyString& operator=(const MyString& str); 

	//字符串拼接 重载+号
	MyString operator+(const char * str );
	MyString operator+(const MyString& str);
	//字符串比较
	bool operator== (const char * str);
	bool operator== (const MyString& str);
private:
	char * pString; //指向堆区空间
	int m_Size; //字符串长度 不算'\0'
};
```

> ```
> #pragma once
> ```
>
> - **作用**：`#pragma once` 是一种预处理指令，用于防止头文件被多次包含（多重定义）。
>
> - **背景**：
>
>   - 在 C/C++ 项目中，头文件可能会被多次包含，导致编译错误（如重复定义函数或变量）。
>
>   - 传统的解决方案是使用“**include guard**”（包含保护）：
>
>     ```cpp
>     // 传统写法
>     #ifndef HEADER_NAME_H
>     #define HEADER_NAME_H
>       
>     // 头文件内容
>       
>     #endif
>     ```
>
> - **优点**：
>
>   - `#pragma once` 是一种更简洁的方式，自动防止头文件的重复包含。
>
>   - 示例：
>
>     ```cpp
>     #pragma once
>     // 头文件内容
>     ```
>
> - **兼容性**：
>
>   - 大多数现代编译器（如 GCC、Clang 和 MSVC）都支持 `#pragma once`。
>   - 少数情况下（如复杂的文件路径结构或旧版编译器），可能无法完全替代 `include guard`。

**MyString.cpp**

```cpp
#include "MyString.h"

//左移运算符
ostream& operator<< (ostream & out, MyString& str)
{
	out << str.pString;
	return out;
}
//右移运算符
istream& operator>>(istream& in, MyString& str)
{
	//先将原有的数据释放
	if (str.pString != NULL)
	{
		delete[] str.pString;
		str.pString = NULL;
	}
	char buf[1024]; //开辟临时的字符数组，保存用户输入内容
	in >> buf;

	str.pString = new char[strlen(buf) + 1];
	strcpy(str.pString, buf);
	str.m_Size = strlen(buf);

	return in;
}

//构造函数
MyString::MyString(const char * str)
{
	this->pString = new char[strlen(str) + 1];
	strcpy(this->pString, str);
	this->m_Size = strlen(str);
}

//拷贝构造
MyString::MyString(const MyString& str)
{
	this->pString = new char[strlen(str.pString) + 1];
	strcpy(this->pString, str.pString);
	this->m_Size = str.m_Size;
}
//析构函数
MyString::~MyString()
{
	if (this->pString!=NULL)
	{
		delete[]this->pString;
		this->pString = NULL;
	}
}

char& MyString::operator[](int index)
{
	return this->pString[index];
}

MyString& MyString::operator=(const char * str)
{
	if (this->pString != NULL){
		delete[] this->pString;
		this->pString = NULL;
	}
	this->pString = new char[strlen(str) + 1];
	strcpy(this->pString, str);
	this->m_Size = strlen(str);
	return *this;
}

MyString& MyString::operator=(const MyString& str)
{
	if (this->pString != NULL){
		delete[] this->pString;
		this->pString = NULL;
	}
	this->pString = new char[strlen(str.pString) + 1];
	strcpy(this->pString, str.pString);
	this->m_Size = str.m_Size;
	return *this;
}


MyString MyString::operator+(const char * str)
{
	int newsize = this->m_Size + strlen(str) + 1;
	char *temp = new char[newsize];
	memset(temp, 0, newsize);
	strcat(temp, this->pString);
	strcat(temp, str);

	MyString newstring(temp);
	delete[] temp;

	return newstring;
}

MyString MyString::operator+(const MyString& str)
{
	int newsize = this->m_Size + str.m_Size + 1;
	char *temp = new char[newsize];
	memset(temp, 0, newsize);
	strcat(temp, this->pString);
	strcat(temp, str.pString);

	MyString newstring(temp);
	delete[] temp;
	return newstring;
}

bool MyString::operator==(const char * str)
{
	if (strcmp(this->pString, str) == 0 && strlen(str) == this->m_Size){
		return true;
	}

	return false;
}

bool MyString::operator==(const MyString& str)
{
	if (strcmp(this->pString, str.pString) == 0 && str.m_Size == this->m_Size){
		return true;
	}

	return false;
}
```

> 方法`MyString MyString::operator+(const char * str)` 中
>
> ```cpp
> char *temp = new char[newsize];
> memset(temp, 0, newsize);
> strcat(temp, this->pString);
> strcat(temp, str.pString);
> ```
>
> 作用：
>
> ```cpp
> char *temp = new char[newsize];
> ```
>
> **解析**
>
> - `char *temp` ：声明一个字符指针 `temp`，将用于存储动态分配的内存地址。
> - `new char[newsize]` ：通过 `new` 操作符分配了一个大小为 `newsize` 的字符数组。
>   - `newsize` 是动态分配的大小，需保证它足够容纳拼接后的字符串以及字符串结束符 `\0`。
>   - 返回值是分配内存的首地址，类型为 `char*`。
>
> **注意事项：**
>
> 1. 分配的内存位于堆中，需要手动释放，否则会引发内存泄漏。
> 2. 默认情况下，`new` 分配的内存内容是**未初始化的（即内存中的值可能是随机值）**。
>
> ```cpp
> memset(temp, 0, newsize);
> ```
>
> **解析**
>
> - `memset` 将 `temp` 指向的内存区域全部初始化为 `0`（表示字符 `'\0'`）。
> - 参数说明：
>   - `temp` ：指向内存的首地址。
>   - `0` ：要填充的值，这里为 `0`，即表示字符结束符 `\0`。
>   - `newsize` ：填充的字节数，即分配的数组大小。
> - **作用**：
>   - 初始化整个字符数组为全零状态，确保字符串操作不会因未初始化的随机值出错。
>
> ```cpp
> strcat(temp, this->pString);
> ```
>
> **解析**
>
> - `strcat` ：将字符串 `this->pString` 拼接到 `temp` 末尾。
> - 工作原理：
>   1. `strcat` 从目标字符串（`temp`）找到字符串结束符 `\0` 的位置。
>   2. 将源字符串（`this->pString`）从其开头逐字节复制到目标字符串末尾。
>   3. 复制完成后，在目标字符串的末尾追加一个新的 `\0`。
>
> **假设：**
>
> - `temp` 此时为空字符串（内容全为 `\0`，因为刚用 `memset` 初始化）。
> - 拼接后，`temp` 的内容为 `this->pString`。
>
> **注意：**
>
> - 若 `this->pString` 的长度超过 `newsize - 1`，会导致缓冲区溢出。
> - 若 `this->pString` 是空字符串，则 `temp` 保持原样。
>
> ```cpp
> strcat(temp, str.pString);
> ```
>
> **解析**
>
> - 再次使用 `strcat`，将另一个字符串 `str.pString` 拼接到 `temp` 的末尾。
> - **操作步骤**：
>   1. 从 `temp` 的当前末尾（由上一次拼接得到）开始。
>   2. 将 `str.pString` 的内容逐字符追加。
>   3. 在拼接后的末尾添加 `\0`。
>
> **最终效果：**
>
> - `temp` 最终的内容为 `this->pString + str.pString`，即两个字符串的连接结果。
>
> **整体逻辑**
>
> **背景**
>
> - 假设这是一个字符串类的成员函数，用于实现两个字符串的拼接。
> - `this->pString` 是当前字符串，`str.pString` 是要拼接的另一个字符串。
>
> **工作步骤**
>
> 1. 动态分配一块新内存 `temp`，大小为 `newsize`，确保足够存放拼接后的字符串。
> 2. 使用 `memset` 初始化内存，将整个数组填充为 `\0`，以便后续拼接不会有多余数据干扰。
> 3. 将当前对象的字符串 `this->pString` 拼接到 `temp`。
> 4. 再将目标字符串 `str.pString` 拼接到 `temp`，形成完整的新字符串。
>
> **代码对应的内存状态变化**
>
> - 假设：
>   - `this->pString = "Hello"`;
>   - `str.pString = "World"`;
>   - `newsize = 12`（10个字符+2个 `\0`）。
>
> | 步骤                 | `temp` 的内容              |
> | -------------------- | -------------------------- |
> | 初始化（`memset`）   | `\0\0\0\0\0\0\0\0\0\0\0\0` |
> | 拼接 `this->pString` | `Hello\0\0\0\0\0\0`        |
> | 拼接 `str.pString`   | `HelloWorld\0\0`           |
>
> 细节补充：不使用memset(temp, 0, newsize);会出现什么问题？
>
> 由于 `temp` 中的内容未初始化，`strcat` 追加的内容可能会与原来存储在 `temp` 中的随机数据发生冲突，导致字符串内容出现错误或被破坏。

**TestMyString.cpp**

```cpp
void test01()
{
	MyString str("hello World");

	cout << str << endl;
	//cout << "请输入MyString类型字符串：" << endl;
	//cin >> str;

	//cout << "字符串为： " << str << endl;

	//测试[]
	cout << "MyString的第一个字符为：" << str[0] << endl;

	//测试 =
	MyString str2 = "^_^";
	MyString str3 = "";
	str3 = "aaaa";
	str3 = str2;
	cout << "str2 = " << str2 << endl;
	cout << "str3 = " << str3 << endl;

	//测试 +
	MyString str4 = "我爱";
	MyString str5 = "北京";
	MyString str6 = str4 + str5;
	MyString str7 = str6 + "天安门";

	cout << str7 << endl;

	//测试 == 
	if (str6 == str7)
	{
		cout << "s6 与 s7相等" << endl;
	}
	else
	{
		cout << "s6 与 s7不相等" << endl;
	}
}
```

### **4.6.12 附录：运算符和结合性**

| 优先级 | 运算符           | 名称或含义               | 使用形式                 | 结合方向 | 说明       |
| ------ | ---------------- | ------------------------ | ------------------------ | -------- | ---------- |
| 1      | []               | 数组下标                 | 数组名[常量表达式]       | 左到右   | --         |
| ()     | 圆括号           | (表达式）/函数名(形参表) | --                       |          |            |
| .      | 成员选择（对象） | 对象.成员名              | --                       |          |            |
| ->     | 成员选择（指针） | 对象指针->成员名         | --                       |          |            |
| 2      | -                | 负号运算符               | -表达式                  | 右到左   | 单目运算符 |
| ~      | 按位取反运算符   | ~表达式                  |                          |          |            |
| ++     | 自增运算符       | ++变量名/变量名++        |                          |          |            |
| --     | 自减运算符       | --变量名/变量名--        |                          |          |            |
| *      | 取值运算符       | *指针变量                |                          |          |            |
| &      | 取地址运算符     | &变量名                  |                          |          |            |
| !      | 逻辑非运算符     | !表达式                  |                          |          |            |
| (类型) | 强制类型转换     | (数据类型)表达式         | --                       |          |            |
| sizeof | 长度运算符       | sizeof(表达式)           | --                       |          |            |
| 3      | /                | 除                       | 表达式/表达式            | 左到右   | 双目运算符 |
| *      | 乘               | 表达式*表达式            |                          |          |            |
| %      | 余数（取模）     | 整型表达式%整型表达式    |                          |          |            |
| 4      | +                | 加                       | 表达式+表达式            | 左到右   | 双目运算符 |
| -      | 减               | 表达式-表达式            |                          |          |            |
| 5      | <<               | 左移                     | 变量<<表达式             | 左到右   | 双目运算符 |
| >>     | 右移             | 变量>>表达式             |                          |          |            |
| 6      | >                | 大于                     | 表达式>表达式            | 左到右   | 双目运算符 |
| >=     | 大于等于         | 表达式>=表达式           |                          |          |            |
| <      | 小于             | 表达式<表达式            |                          |          |            |
| <=     | 小于等于         | 表达式<=表达式           |                          |          |            |
| 7      | ==               | 等于                     | 表达式==表达式           | 左到右   | 双目运算符 |
| ！=    | 不等于           | 表达式!= 表达式          |                          |          |            |
| 8      | &                | 按位与                   | 表达式&表达式            | 左到右   | 双目运算符 |
| 9      | ^                | 按位异或                 | 表达式^表达式            | 左到右   | 双目运算符 |
| 10     | \|               | 按位或                   | 表达式\|表达式           | 左到右   | 双目运算符 |
| 11     | &&               | 逻辑与                   | 表达式&&表达式           | 左到右   | 双目运算符 |
| 12     | \|\|             | 逻辑或                   | 表达式\|\|表达式         | 左到右   | 双目运算符 |
| 13     | ?:               | 条件运算符               | 表达式1?表达式2: 表达式3 | 右到左   | 三目运算符 |
|        |                  |                          |                          |          |            |
| 14     | =                | 赋值运算符               | 变量=表达式              | 右到左   | --         |
| /=     | 除后赋值         | 变量/=表达式             | --                       |          |            |
| *=     | 乘后赋值         | 变量*=表达式             | --                       |          |            |
| %=     | 取模后赋值       | 变量%=表达式             | --                       |          |            |
| +=     | 加后赋值         | 变量+=表达式             | --                       |          |            |
| -=     | 减后赋值         | 变量-=表达式             | --                       |          |            |
| <<=    | 左移后赋值       | 变量<<=表达式            | --                       |          |            |
| >>=    | 右移后赋值       | 变量>>=表达式            | --                       |          |            |
| &=     | 按位与后赋值     | 变量&=表达式             | --                       |          |            |
| ^=     | 按位异或后赋值   | 变量^=表达式             | --                       |          |            |
| \|=    | 按位或后赋值     | 变量\|=表达式            | --                       |          |            |
| 15     | ，               | 逗号运算符               | 表达式,表达式,…          | 左到右   | --         |

## **4.7 继承和派生**

### **4.7.1 继承概述**

#### **4.7.1.1 为什么需要继承**

![2024-11-11_15-27-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-27-09.png.png)

![2024-11-11_15-28-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-28-09.png.png)

```cpp
网页类
class IndexPage{
public:
	//网页头部
	void Header(){
		cout << "网页头部!" << endl;
	}
	//网页左侧菜单
	void LeftNavigation(){
		cout << "左侧导航菜单!" << endl;
	}
	//网页主体部分
	void MainBody(){
		cout << "首页网页主题内容!" << endl;
	}
	//网页底部
	void Footer(){
		cout << "网页底部!" << endl;
	}
private:
	string mTitle; //网页标题
};

#if 0
//如果不使用继承，那么定义新闻页类，需要重新写一遍已经有的代码
class NewsPage{
public:
	//网页头部
	void Header(){
		cout << "网页头部!" << endl;
	}
	//网页左侧菜单
	void LeftNavigation(){
		cout << "左侧导航菜单!" << endl;
	}
	//网页主体部分
	void MainBody(){
		cout << "新闻网页主体内容!" << endl;
	}
	//网页底部
	void Footer(){
		cout << "网页底部!" << endl;
	}
private:
	string mTitle; //网页标题
};

void test(){
	NewsPage* newspage = new NewsPage;
	newspage->Header();
	newspage->MainBody();
	newspage->LeftNavigation();
	newspage->Footer();
}
#else
//使用继承，可以复用已有的代码，新闻业除了主体部分不一样，其他都是一样的
class NewsPage : public IndexPage{
public:
	//网页主体部分
	void MainBody(){
		cout << "新闻网页主主体内容!" << endl;
	}
};
void test(){
	NewsPage* newspage = new NewsPage;
	newspage->Header();
	newspage->MainBody();
	newspage->LeftNavigation();
	newspage->Footer();
}
#endif
int main(){

	test();

	return EXIT_SUCCESS;
}
```

#### **4.7.1.2 继承基本概念**

c++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。

一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类）， 类B成为派生类（子类）。

派生类中的成员，包含两大部分：

- 一类是从基类继承过来的，一类是自己增加的成员。
- 从基类继承过过来的表现其共性，而新增的成员体现了其个性。

![2024-11-11_15-29-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-29-09.png.jpeg)

#### **4.7.1.3 派生类定义**

**派生类定义格式：**

```cpp
   Class 派生类名 :  继承方式 基类名{
         //派生类新增的数据成员和成员函数
   }
```

三种继承方式：

- public ： 公有继承
- private ： 私有继承
- protected ： 保护继承

从继承源上分：

- 单继承：指每个派生类只直接继承了一个基类的特征
- 多继承：指多个基类派生出一个派生类的继承关系,多继承的派生类直接继承了不止一个基类的特征

### **4.7.2 派生类访问控制**

派生类继承基类，派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法），但是在派生类中，继承的成员并不一定能直接访问，不同的继承方式会导致不同的访问权限。

派生类的访问权限规则如下：

![2024-11-11_15-30-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-30-09.png.png)

![2024-11-11_15-31-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-31-09.png.png)

```cpp
//基类
class A{
public:
	int mA;
protected:
	int mB;
private:
	int mC;
};

//1. 公有(public)继承
class B : public A{
public:
	void PrintB(){
		cout << mA << endl; //可访问基类public属性
		cout << mB << endl; //可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
class SubB : public B{
	void PrintSubB(){
		cout << mA << endl; //可访问基类public属性
		cout << mB << endl; //可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
void test01(){

	B b;
	cout << b.mA << endl; //可访问基类public属性
	//cout << b.mB << endl; //不可访问基类protected属性
	//cout << b.mC << endl; //不可访问基类private属性
}

//2. 私有(private)继承
class C : private A{
public:
	void PrintC(){
		cout << mA << endl; //可访问基类public属性
		cout << mB << endl; //可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
class SubC : public C{
	void PrintSubC(){
		//cout << mA << endl; //不可访问基类public属性
		//cout << mB << endl; //不可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
void test02(){
	C c;
	//cout << c.mA << endl; //不可访问基类public属性
	//cout << c.mB << endl; //不可访问基类protected属性
	//cout << c.mC << endl; //不可访问基类private属性
}
//3. 保护(protected)继承
class D : protected A{
public:
	void PrintD(){
		cout << mA << endl; //可访问基类public属性
		cout << mB << endl; //可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
class SubD : public D{
	void PrintD(){
		cout << mA << endl; //可访问基类public属性
		cout << mB << endl; //可访问基类protected属性
		//cout << mC << endl; //不可访问基类private属性
	}
};
void test03(){
	D d;
	//cout << d.mA << endl; //不可访问基类public属性
	//cout << d.mB << endl; //不可访问基类protected属性
	//cout << d.mC << endl; //不可访问基类private属性
}
```

### **4.7.3 继承中的构造和析构**

#### **4.7.3.1 继承中的对象模型**

在C++编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成：

```cpp
class Aclass{
public:
	int mA;
	int mB;
};
class Bclass : public Aclass{
public:
	int mC;
};
class Cclass : public Bclass{
public:
	int mD;
};
void test(){
	cout << "A size:" << sizeof(Aclass) << endl;
	cout << "B size:" << sizeof(Bclass) << endl;
	cout << "C size:" << sizeof(Cclass) << endl;
}
```

> 输出：
>
> A size:8
>
> B size:12
>
> C size:16

#### **4.7.3.2 对象构造和析构的调用原则**

**继承中的构造和析构**

- 子类对象在创建时会首先调用父类的构造函数
- 父类构造函数执行完毕后，才会调用子类的构造函数
- 当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数
- 析构函数调用顺序和构造函数相反

> **当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数。这句话具体意思为：**
>
> 当父类的构造函数有参数时，子类必须在其初始化列表中显式调用父类的构造函数，并传递适当的参数。这样，子类在创建时会先调用父类的构造函数来初始化父类部分。
>
> 例如：
>
> ```cpp
> class Base {
> public:
>     Base(int x) { std::cout << "Base class constructor, x = " << x << std::endl; }
> };
> 
> class Derived : public Base {
> public:
>     Derived(int x, int y) : Base(x) {  // 显式调用父类的构造函数
>         std::cout << "Derived class constructor, y = " << y << std::endl;
>     }
> };
> 
> int main() {
>     Derived obj(10, 20);  // 会先调用 Base(int) 构造函数，再调用 Derived 构造函数
>     return 0;
> }
> ```
>
> **解释：**
>
> - **父类 Base** 有一个带参数的构造函数 `Base(int x)`。
> - **子类 Derived** 在其初始化列表中通过 `Base(x)` 调用父类的构造函数并传递参数 `x`，以确保父类部分被正确初始化。
>
> 如果父类没有显式调用父类构造函数，编译器会报错，因为它不知道如何初始化父类对象。

![2024-11-11_15-32-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-32-09.png.png)

```cpp
class A{
public:
	A(){
		cout << "A类构造函数!" << endl;
	}
	~A(){
		cout << "A类析构函数!" << endl;
	}
};

class B : public A{
public:
	B(){
		cout << "B类构造函数!" << endl;
	}
	~B(){
		cout << "B类析构函数!" << endl;
	}
};

class C : public B{
public:
	C(){
		cout << "C类构造函数!" << endl;
	}
	~C(){
		cout << "C类析构函数!" << endl;
	}
};

void test(){
	C c;
}
```

- **继承与组合混搭的构造和析构**

![2024-11-11_15-33-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-33-09.png.png)

```cpp
class D{
public:
    D(){
        cout << "D类构造函数!" << endl;
    }
    ~D(){
        cout << "D类析构函数!" << endl;
    }
};
class A{
public:
    A(){
        cout << "A类构造函数!" << endl;
    }
    ~A(){
        cout << "A类析构函数!" << endl;
    }
};
class B : public A{
public:
    B(){
        cout << "B类构造函数!" << endl;
    }
    ~B(){
        cout << "B类析构函数!" << endl;
    }
public:
    D c;
};
class C : public B{
public:
    C(){
        cout << "C类构造函数!" << endl;
    }
    ~C(){
        cout << "C类析构函数!" << endl;
    }
public:
    D c;
};
void test(){
    C c;
}
/*输出：

A类构造函数!

D类构造函数!

B类构造函数!

D类构造函数!

C类构造函数!

C类析构函数!

D类析构函数!

B类析构函数!

D类析构函数!

A类析构函数!*/
```

> 先构建对象类型的成员属性再构建对应的对象本身。

### **4.7.4 继承中同名成员的处理方法**

- 当子类成员和父类成员同名时，子类依然从父类继承同名成员
- 如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)（前提是这里没有多态，见说明）
- 在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)

```cpp
class Base{
public:
    Base():mParam(0){}
    void Print(){ cout << mParam << endl; }
public:
    int mParam;
};

class Derived : public Base{
public:
    Derived():mParam(10){}
    void Print(){
        //在派生类中使用和基类的同名成员,显示使用类名限定符
        cout << Base::mParam << endl;
        cout << mParam << endl;
    }
    //返回基类重名成员
    int& getBaseParam(){ return  Base::mParam; }
public:
    int mParam;
};

int main(){

    Derived derived;
    //派生类和基类成员属性重名，子类访问成员默认是子类成员
    cout << derived.mParam << endl; //10
    derived.Print();
    //类外如何获得基类重名成员属性
    derived.getBaseParam() = 100;
    cout << "Base:mParam:" << derived.getBaseParam() << endl;
return EXIT_SUCCESS;
}
/*
10
0
10
Base:mParam:100*/
```

> 注意：派生类和基类成员属性重名，子类访问成员默认是子类成员。前提是没有用多态。原因如下：
>
> 假如用了多态，即`Derived tempt; Base derived= tempt;` 或`Base* derived=new Derived();` 语句`cout << derived.mParam或derived->mParam << endl;` 的输出都会是基类的成员属性，也就是0而不是10。

**注意: 如果重新定义了基类中的重载函数，将会发生什么？**

```cpp
class Base{
public:
    void func1(){
        cout << "Base::void func1()" << endl;
    };
    void func1(int param){
        cout << "Base::void func1(int param)" << endl;
    }
    void myfunc(){
        cout << "Base::void myfunc()" << endl;
    }
};
class Derived1 : public Base{
public:
    void myfunc(){
        cout << "Derived1::void myfunc()" << endl;
    }
};
class Derived2 : public Base{
public:
    //改变成员函数的参数列表
    void func1(int param1, int param2){
        cout << "Derived2::void func1(int param1,int param2)" << endl;
    };
};
class Derived3 : public Base{
public:
    //改变成员函数的返回值
    int func1(int param){
        cout << "Derived3::int func1(int param)" << endl;
        return 0;
    }
};
int main(){

    Derived1 derived1;
    derived1.func1();
    derived1.func1(20);
    derived1.myfunc();
    cout << "-------------" << endl;
    Derived2 derived2;
    //derived2.func1();  //func1被隐藏
    //derived2.func1(20); //func2被隐藏
    derived2.func1(10,20); //重载func1之后，基类的函数被隐藏
    derived2.myfunc();
    cout << "-------------" << endl;
    Derived3 derived3;
    //derived3.func1();  没有重新定义的重载版本被隐藏
    derived3.func1(20);
    derived3.myfunc();

    return EXIT_SUCCESS;
}
/*
Base::void func1()
Base::void func1(int param)
Derived1::void myfunc()
-------------
Derived2::void func1(int param1,int param2)
Base::void myfunc()
-------------
Derived3::int func1(int param)
Base::void myfunc()*/
```

> - Derive1 重定义了Base类的myfunc函数，derive1可访问func1及其重载版本的函数。
> - Derive2通过改变函数参数列表的方式重新定义了基类的func1函数，则从基类中继承来的其他重载版本被隐藏，不可访问。
> - Derive3通过改变函数返回类型的方式重新定义了基类的func1函数，则从基类继承来的没有重新定义的重载版本的函数将被隐藏。

任何时候重新定义基类中的一个重载函数，在新类中所有的其他版本将被自动隐藏.

### **4.7.5 非自动继承的函数**

不是所有的函数都能自动从基类继承到派生类中。构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。

另外operator=也不能被继承，因为它完成类似构造函数的行为。也就是说尽管我们知道如何由=右边的对象如何初始化=左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。

在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。

> 编译器会默认生成的特殊成员函数（Rule of Zero/Rule of Five）：
>
> 1. **默认构造函数**：`MyClass();`
> 2. **拷贝构造函数**：`MyClass(const MyClass& other);`
> 3. **拷贝赋值运算符**：`MyClass& operator=(const MyClass& other);`
> 4. **析构函数**：`~MyClass();`
> 5. **移动构造函数**：`MyClass(MyClass&& other) noexcept;` （C++11及之后）
> 6. **移动赋值运算符**：`MyClass& operator=(MyClass&& other) noexcept;` （C++11及之后）
>
> 以上这些函数在继承的派生类中也同样会自动生成。
>
> 当然前面两者自动生成的特殊成员的前提是：用户没有显式定义特殊成员函数。

### **4.7.6 继承中的静态成员特性**

静态成员函数和非静态成员函数的共同点:

1. 他们都可以被继承到派生类中。
2. 如果重新定义一个静态成员函数，所有在基类中的其他重载函数会被隐藏。
3. 如果我们改变基类中一个函数的特征，所有使用该函数名的基类版本都会被隐藏。

```cpp
class Base{
public:
	static int getNum(){ return sNum; }
	static int getNum(int param){
		return sNum + param;
	}
public:
	static int sNum;
};
int Base::sNum = 10;

class Derived : public Base{
public:
	static int sNum; //基类静态成员属性将被隐藏
#if 0
	//重定义一个函数，基类中重载的函数被隐藏
	static int getNum(int param1, int param2){
		return sNum + param1 + param2;
	}
#else
	//改变基类函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数
	static void getNum(int param1, int param2){
		cout <<  sNum + param1 + param2 << endl;
	}
#endif
};
int Derived::sNum = 20;
```

### **4.7.7 多继承**

#### **4.7.7.1 多继承概念**

我们可以从一个类继承，我们也可以能同时从多个类继承，这就是多继承。但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。

![2024-11-11_15-34-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-34-09.png.png)

```cpp
class Base1{
public:
	void func1(){ cout << "Base1::func1" << endl; }
};
class Base2{
public:
	void func1(){ cout << "Base2::func1" << endl; }
	void func2(){ cout << "Base2::func2" << endl; }
};
//派生类继承Base1、Base2
class Derived : public Base1, public Base2{};
int main(){

	Derived derived;
	//func1是从Base1继承来的还是从Base2继承来的？
	//derived.func1(); 
	derived.func2();

	//解决歧义:显示指定调用那个基类的func1
	derived.Base1::func1(); 
	derived.Base2::func1();

	return EXIT_SUCCESS;
}
```

> 多继承会带来一些二义性的问题， 如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？
>
> 解决方法就是显示指定调用那个基类的版本。

#### **4.7.7.2 菱形继承和虚继承**

> 两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石型继承。
>
> ![2024-11-11_15-35-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-35-09.png.jpeg)

这种继承所带来的问题：

1. 羊继承了动物的数据和函数，鸵同样继承了动物的数据和函数，当草泥马调用函数或者数据时，就会产生二义性。
2. 草泥马继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。

```cpp
class BigBase{
public:
    BigBase(){ mParam = 0; }
    void func(){ cout << "BigBase::func" << endl; }
public:
    int mParam;
};

class Base1 : public BigBase{};
class Base2 : public BigBase{};
class Derived : public Base1, public Base2{};

int main(){

    Derived derived;
    //1. 对“func”的访问不明确
    //derived.func();
    //cout << derived.mParam << endl;
    cout << "derived.Base1::mParam:" << derived.Base1::mParam << endl;
    cout << "derived.Base2::mParam:" << derived.Base2::mParam << endl;

    //2. 重复继承
    cout << "Derived size:" << sizeof(Derived) << endl; //8

    return EXIT_SUCCESS;
}
/*derived.Base1::mParam:0
derived.Base2::mParam:0
Derived size:8*/
```

上述问题如何解决？对于调用二义性，那么可通过指定调用那个基类的方式来解决，那么重复继承怎么解决？

对于这种菱形继承所带来的两个问题，c++为我们提供了一种方式，采用虚基类。那么我们采用虚基类方式将代码修改如下：

```cpp
class BigBase{
public:
    BigBase(){ mParam = 0; }
    void func(){ cout << "BigBase::func" << endl; }
public:
    int mParam;
};

class Base1 : virtual public BigBase{};
class Base2 : virtual public BigBase{};
class Derived : public Base1, public Base2{};

int main(){
    BigBase hh;
    Derived derived;
    Base1 base1;
    Base2 base2;
    //二义性问题解决
    derived.func();
    cout << derived.mParam << endl;
    //输出结果:12
    cout << "Derived size:" << sizeof(hh) << endl;
    cout << "Derived size:" << sizeof(Derived) << endl;
    cout << "Derived size:" << sizeof(base1) << endl;
    cout << "Derived size:" << sizeof(base2) << endl;

    return EXIT_SUCCESS;
}
/*BigBase::func
0
Derived size:4
Derived size:24
Derived size:16
Derived size:16*/
```

> `sizeof(Derived)`**输出24分析：**
>
> `Derived` 类的大小为 **24 字节** 是由于虚继承的内存布局及其附带的开销。我们可以从以下几个方面分析这一现象。
>
> **1. 类成员的基本结构**
>
> `BigBase` **的大小**
>
> `BigBase` 包含一个 `int mParam` 成员变量，占 **4 字节**，其余部分可能会因为对齐填充。
>
> 在常见的平台（如 64 位系统）中，类的大小会对齐到指针大小（8 字节）的倍数。因此：
>
> - `BigBase` 实际大小通常为 **8 字节**（4 字节的 `mParam` + 4 字节填充）。
>
> **虚继承的影响**
>
> `Base1` 和 `Base2` 虚继承 `BigBase`。虚继承需要在派生类（`Derived`）中为每个虚基类存储一个 **虚基表指针（vptr）** 。在 64 位系统中，每个虚指针通常占 **8 字节**。
>
> - `Base1` 和 `Base2` 都有虚基表指针，指向 `BigBase` 的共享实例。
> - 派生类 `Derived` 中会包含这些指针的存储空间。
>
> **2. Derived 类的内存布局**
>
> `Derived` 类中各部分的内存布局如下：
>
> 1. 一个 `BigBase` 的实例共享。
> 2. 每个虚继承路径的虚基表指针。
> 3. 内存对齐的额外填充。
>
> **具体计算**
>
> 在 64 位系统上，`Derived` 的内存布局可能如下：
>
> - `BigBase` 中的成员 `mParam`（共享的）占 **4 字节**。
> - 两个虚基表指针（来自 `Base1` 和 `Base2`），每个占 **8 字节**，共 **16 字节**。
> - 对齐填充到指针大小的倍数（总大小需要是 8 的倍数）。
>
> 计算总大小：
>
> - 4 字节（`mParam`）+ 16 字节（2 个虚基表指针）= **20 字节**。
> - 对齐到 8 的倍数，总大小为 **24 字节**。
>
> **3. 为什么输出是 24？**
>
> 在 `Derived` 中：
>
> - 虚继承引入了两个虚基表指针，每个 8 字节，共占 **16 字节**。
> - `BigBase` 的成员变量 `mParam` 共享，占 **4 字节**。
> - 额外填充以对齐到 8 的倍数，总大小为 **24 字节**。
>
> **4. 平台和编译器的影响**
>
> 内存布局可能因平台、编译器和编译选项而异。一般来说，虚继承引入的虚表指针和对齐填充是主要的内存开销来源。
>
> **结论**
>
> `Derived` 的大小为 **24 字节** 是因为：
>
> 1. **虚继承机制** 为每个虚基类分配虚表指针，占用 **16 字节**。
> 2. `BigBase` 的共享实例 只占 **4 字节**。
> 3. **对齐填充** 将总大小扩展到 8 的倍数。

以上程序Base1 ，Base2采用虚继承方式继承BigBase,那么BigBase被称为虚基类。

通过虚继承解决了菱形继承所带来的二义性问题。

**但是虚基类是如何解决二义性的呢？**

#### **4.7.7.3 虚继承实现原理**

```cpp
class BigBase{
public:
	BigBase(){ mParam = 0; }
	void func(){ cout << "BigBase::func" << endl; }
public: int mParam;
};
#if 0 //虚继承
class Base1 : virtual public BigBase{};
class Base2 : virtual public BigBase{};
#else //普通继承
class Base1 :  public BigBase{};
class Base2 :  public BigBase{};
#endif
class Derived : public Base1, public Base2{};
```

通过内存图，我们发现普通继承和虚继承的对象内存图是不一样的。我们也可以猜测到编译器肯定对我们编写的程序做了一些手脚。

- BigBase 菱形最顶层的类，内存布局图没有发生改变。
- Base1和Base2通过虚继承的方式派生自BigBase,这两个对象的布局图中可以看出编译器为我们的对象中增加了一个vbptr (virtual base pointer),vbptr指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。
- Derived派生于Base1和Base2,继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量。

> 由此可知编译器帮我们做了一些幕后工作，使得这种菱形问题在继承时候能只继承一份数据，并且也解决了二义性的问题。现在模型就变成了Base1和 Base2 Derived三个类对象共享了一份BigBase数据。
>
> **为什么要虚继承？**
>
> - 在普通的继承（非虚继承）中，每个继承的类会单独保存一份基类的实例，导致派生类中会有多个基类的副本。
> - 通过虚继承，C++ 保证只有一个基类对象被共享，这样就避免了二义性问题。

当使用虚继承时，虚基类是被共享的，也就是在继承体系中无论被继承多少次，对象内存模型中均只会出现一个虚基类的子对象（这和多继承是完全不同的）。即使共享虚基类，但是必须要有一个类来完成基类的初始化（因为所有的对象都必须被初始化，哪怕是默认的），同时还不能够重复进行初始化，那到底谁应该负责完成初始化呢？C++标准中选择在**每一次继承子类**中都必须书写初始化语句（因为每一次继承子类可能都会用来定义对象），但是虚基类的初始化是由最后的子类完成，其他的初始化语句都不会调用。

```cpp
class BigBase{
public:
    BigBase(int x){
        mParam = x;
        cout << "BigBase constructor" << endl;
        cout << "Derived.mParam: " << mParam << endl;
    }
    void func(){cout << "BigBase::func" << endl;}
public:
    int mParam;
};
class Base1 : virtual public BigBase{
public:
    Base1() :BigBase(1){
        cout << "Base1 constructor" << endl;
        cout << "Derived.mParam: " << mParam << endl;
    } //不调用BigBase构造
};
class Base2 : virtual public BigBase{
public:
    Base2() :BigBase(2){
        cout << "Base2 constructor" << endl;
        cout << "Derived.mParam: " << mParam << endl;
    } //不调用BigBase构造
};

class Derived : public Base1, public Base2{
public:
    Derived() :BigBase(3){
        cout << "Derived constructor" << endl;
        cout << "Derived.mParam: " << mParam << endl;
            } //调用BigBase构造
};
//每一次继承子类中都必须书写初始化语句
int main(){
    Derived derived;
    cout << "Derived.mParam: " << derived.mParam << endl;
    return EXIT_SUCCESS;
}
/*
BigBase constructor
Derived.mParam: 3
Base1 constructor
Derived.mParam: 3
Base2 constructor
Derived.mParam: 3
Derived constructor
Derived.mParam: 3
Derived.mParam: 3*/
```

**注意：**

虚继承只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承的。

工程开发中真正意义上的多继承是几乎不被使用，因为多重继承带来的代码复杂性远多于其带来的便利，多重继承对代码维护性上的影响是灾难性的，在设计方法上，任何多继承都可以用单继承代替。

## **4.8 多态**

### **4.8.1 多态基本概念**

多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。

多态性(polymorphism)提供接口与具体实现之间的另一层隔离，从而将"what"和"how"分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。

c++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。

静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定(动态多态,运行时多态)。

```cpp
//计算器
class Caculator{
public:
	void setA(int a){
		this->mA = a;
	}
	void setB(int b){
		this->mB = b;
	}
	void setOperator(string oper){
		this->mOperator = oper;
	}
	int getResult(){
		
		if (this->mOperator == "+"){
			return mA + mB;
		}
		else if (this->mOperator == "-"){
			return mA - mB;
		}
		else if (this->mOperator == "*"){
			return mA * mB;
		}
		else if (this->mOperator == "/"){
			return mA / mB;
		}
	}
private:
	int mA;
	int mB;
	string mOperator;
};

//这种程序不利于扩展，维护困难，如果修改功能或者扩展功能需要在源代码基础上修改
//面向对象程序设计一个基本原则:开闭原则(对修改关闭，对扩展开放)

//抽象基类
class AbstractCaculator{
public:
	void setA(int a){
		this->mA = a;
	}
	virtual void setB(int b){
		this->mB = b;
	}
	virtual int getResult() = 0;//纯虚函数
protected:
	int mA;
	int mB;
	string mOperator;
};

//加法计算器
class PlusCaculator : public AbstractCaculator{
public:
	virtual int getResult(){
		return mA + mB;
	}
};

//减法计算器
class MinusCaculator : public AbstractCaculator{
public:
	virtual int getResult(){
		return mA - mB;
	}
};

//乘法计算器
class MultipliesCaculator : public AbstractCaculator{
public:
	virtual int getResult(){
		return mA * mB;
	}
};

void DoBussiness(AbstractCaculator* caculator){
	int a = 10;
	int b = 20;
	caculator->setA(a);
	caculator->setB(b);
	cout << "计算结果：" << caculator->getResult() << endl;
	delete caculator;
}
```

> **virtual void setB(int b)方法为什么使用virtual（同理**virtual int getResult()**）？**
>
> 回答：对于 `AbstractCaculator` 类，`setB` 被定义为虚函数，这表明：
>
> - **允许派生类根据需要重写该方法**。
> - 在使用基类指针或引用调用该方法时，会调用实际对象的重写版本，而不是基类的版本。
>
> 虽然在当前代码中，`setB` 在派生类中没有被重写，但保留其 `virtual` 修饰符，表明该方法可以被派生类定制。如果未来扩展派生类需要特殊逻辑来处理 `setB`，可以轻松实现。
>
> **对比：非虚函数的行为**
>
> 如果 `setB` 没有声明为 `virtual`，则即使派生类重写了该方法，当通过基类指针调用 `setB` 时，仍然会调用基类版本，这会导致非预期的行为。

### **4.8.2 向上类型转换及问题**

#### **4.8.2.1 问题抛出**

对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。

也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。

```cpp
class Animal{
public:
	void speak(){
		cout << "动物在唱歌..." << endl;
	}
};

class Dog : public Animal{
public:
	void speak(){
		cout << "小狗在唱歌..." << endl;
	}
};

void DoBussiness(Animal& animal){
	animal.speak();
}

void test(){
	Dog dog;
	DoBussiness(dog);
}
```

> 运行结果: 动物在唱歌
>
> 问题抛出: 我们给DoBussiness传入的对象是dog，而不是animal对象，输出的结果应该是Dog::speak（当然这里通过上一小节的示例说明可知这里使用虚函数就可以解决）。

#### **4.8.2.2 问题解决思路**

解决这个问题，我们需要了解下绑定(捆绑,binding)概念。

> 把函数体与函数调用相联系称为绑定(捆绑，binding)

当绑定在程序运行之前(由编译器和连接器)完成时，称为早绑定(early binding).C语言中只有一种函数调用方式，就是早绑定。

上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译**是根据指向对象的指针或引用的类型**来选择函数调用。这个时候由于DoBussiness的参数类型是Animal&,编译器确定了应该调用的speak是Animal::speak的，而不是真正传入的对象Dog::speak。

解决方法就是迟绑定(迟捆绑,动态绑定,运行时绑定，late binding),意味着绑定要根据对象的实际类型，发生在运行。

C++语言要实现这种动态绑定，必须有某种机制来确定运行时对象的类型并调用合适的成员函数。对于一种编译语言，编译器并不知道实际的对象类型（编译器并不知道Animal类型的指针或引用指向的实际的对象类型）。

#### **4.8.2.3 问题解决方案(虚函数,vitual function)**

C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。

对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字,动态绑定也就对virtual函数起作用.

- 为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要.
- 如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的.
- 在派生类中virtual函数的重定义称为重写(override).
- Virtual关键字只能修饰成员函数.
- 构造函数不能为虚函数

> **注意:** 仅需要在基类中声明一个函数为virtual.调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual(这也是无害的)，但这个样会使得程序显得冗余和杂乱。(建议写上)

```cpp
class Animal{
public:
	virtual void speak(){
		cout << "动物在唱歌..." << endl;
	}
};
class Dog : public Animal{
public:
	virtual void speak(){
		cout << "小狗在唱歌..." << endl;
	}
};
void DoBussiness(Animal& animal){
	animal.speak();
}
void test(){
	Dog dog;
	DoBussiness(dog);
}
```

### **4.8.3 C++如何实现动态绑定**

动态绑定什么时候发生？所有的工作都是由编译器在幕后完成。当我们告诉通过创建一个virtual函数来告诉编译器要进行动态绑定，那么编译器就会根据动态绑定机制来实现我们的要求， 不会再执行早绑定。

**问题:C++的动态捆绑机制是怎么样的？**

首先，我们看看编译器如何处理虚函数。当编译器发现我们的类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vpointer(缩写vptr)，这个指针是指向对象的虚函数表。在多态调用的时候，根据vptr指针，找到虚函数表来实现动态绑定。

验证对象中的虚指针：

```cpp
class A{
public:
    virtual void func1(){}
    virtual void func2(){}
};

//B类为空，那么大小应该是1字节，实际情况是这样吗？
class B : public A{};

void test(){
    cout << "A size:" << sizeof(A) << endl;
    cout << "B size:" << sizeof(B) << endl;
}
/*A size:8
B size:8*/
```

> 对象成员属性为空时，对象的大小为1。

在编译阶段，编译器秘密增加了一个vptr指针，但是此时vptr指针并没有初始化指向虚函数表(vtable),什么时候vptr才会指向虚函数表？在对象构建的时候，也就是在对象初始化调用构造函数的时候。编译器首先默认会在我们所编写的每一个构造函数中，增加一些vptr指针初始化的代码。如果没有提供构造函数，编译器会提供默认的构造函数，那么就会在默认构造函数里做此项工作，初始化vptr指针，使之指向本对象的虚函数表。

起初，子类继承基类，子类继承了基类的vptr指针，这个vptr指针是指向基类虚函数表，当子类调用构造函数，使得子类的vptr指针指向了子类的虚函数表。

- 当子类无重写基类虚函数时:

![2024-11-11_15-42-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-42-09.png.jpeg)

![2024-11-11_15-43-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-43-09.png.png)

> **过程分析:**
>
> Animal* animal = new Dog;
>
> animal->fun1();
>
> 当程序执行到这里，会去animal指向的空间中寻找vptr指针，通过vptr指针找到func1函数，此时由于子类并没有重写也就是覆盖基类的func1函数，所以调用func1时，仍然调用的是基类的func1.
>
> **执行结果:** 我是基类的func1
>
> **测试结论:** 无重写基类的虚函数，无意义

- 当子类重写基类虚函数时:

![2024-11-11_15-44-09.png.jpeg](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-44-09.png.jpeg)

![2024-11-11_15-45-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-45-09.png.png)

> **过程分析:**
>
> Animal* animal = new Dog;
>
> animal->fun1();
>
> 当程序执行到这里，会去animal指向的空间中寻找vptr指针，通过vptr指针找到func1函数，由于子类重写基类的func1函数，所以调用func1时，调用的是子类的func1.
>
> **执行结果:** 我是子类的func1
>
> **测试结论:** 无重写基类的虚函数，无意义

> **多态的成立条件：**
>
> - 有继承
> - 子类重写父类虚函数函数
>
> a) 返回值，函数名字，函数参数，必须和父类完全一致(析构函数除外)
>
> b) 子类中virtual关键字可写可不写，建议写
>
> - 类型兼容，父类指针，父类引用 指向 子类对象

> **虚函数必要的补充说明：**
>
> **1.每个类都有自己的虚函数表，派生类也不例外（即使没有重写函数）；**
>
> **2.虚函数表的存储位置**
>
> - **虚函数表（VTable）** 是由编译器生成的，每个类的虚函数表是唯一的，存储在**静态存储区**，与类绑定。
>   - 每个类只有一个虚函数表，无论该类的对象有多少个。
>   - 表中记录了指向虚函数实现的函数指针，供对象调用时动态查找。
>
> **3. 虚指针（vptr）的存储位置**
>
> - 每个支持多态的对象（拥有虚函数的类的实例）中包含一个隐式的虚指针（vptr）。
> - **虚指针的存储位置**取决于对象分配的方式：
>   - 如果对象是**局部变量**（分配在栈上），`vptr`存储在栈上。
>   - 如果对象是通过 `new` 动态分配的（分配在堆上），`vptr`存储在堆上的对象内存中。
>   - 如果对象是全局变量或静态变量，`vptr`存储在静态存储区的该对象的内存中。

### **4.8.4 抽象基类和纯虚函数(pure virtual function)**

在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。

做到这点，可以在基类中加入至少一个纯虚函数(pure virtual function),使得基类称为抽象类(abstract class).

- 纯虚函数使用关键字virtual，并在其后面加上=0。
- 如果试图去实例化一个抽象类，编译器则会阻止这种操作。
- 当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。
- Virtual void fun() = 0;告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。

> 在C++中，声明一个纯虚函数（`virtual void fun() = 0;`）意味着该函数必须在某个派生类中被实现。编译器会在虚函数表（VTable）中为这个纯虚函数保留一个条目，但在基类中不会为它提供实际的函数地址。这是因为基类本身并没有提供该函数的实现。
>
> **详细说明**
>
> 1. **纯虚函数的VTable条目**：
>    - 对于一个声明了纯虚函数的类，其虚函数表会有一个与该函数对应的条目。
>    - 在基类的虚函数表中，这个条目的值通常是一个特殊的指针，比如 `nullptr`，或者指向编译器定义的一个错误处理函数（例如`__purecall`）。
>    - 这个条目表明该函数是纯虚的，调用它会导致程序崩溃或触发错误。
> 2. **派生类的实现**：
>    - 如果派生类实现了这个纯虚函数，那么在派生类的虚函数表中，这个条目会被更新为指向派生类中实现的函数地址。
>    - 因此，派生类可以通过其虚函数表调用具体的实现。

**建立公共接口目的**是为了将子类公共的操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共接口不需要事先(或者不需要完全实现)。可以创建一个公共类。

**案例: 模板方法模式**

![2024-11-11_15-46-09.png.png](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/11/2024-11-11_15-46-09.png.png)

```cpp
//抽象制作饮品
class AbstractDrinking{
public:
    //烧水
    virtual void Boil() = 0;
    //冲泡
    virtual void Brew() = 0;
    //倒入杯中
    virtual void PourInCup() = 0;
    //加入辅料
    virtual void PutSomething() = 0;
    //规定流程
    void MakeDrink(){
        Boil();
        Brew();
        PourInCup();
        PutSomething();
    }
};

//制作咖啡
class Coffee : public AbstractDrinking{
public:
    //烧水
    virtual void Boil(){
        cout << "煮农夫山泉!" << endl;
    }
    //冲泡
    virtual void Brew(){
        cout << "冲泡咖啡!" << endl;
    }
    //倒入杯中
    virtual void PourInCup(){
        cout << "将咖啡倒入杯中!" << endl;
    }
    //加入辅料
    virtual void PutSomething(){
        cout << "加入牛奶!" << endl;
    }
};

//制作茶水
class Tea : public AbstractDrinking{
public:
    //烧水
    virtual void Boil(){
        cout << "煮自来水!" << endl;
    }
    //冲泡
    virtual void Brew(){
        cout << "冲泡茶叶!" << endl;
    }
    //倒入杯中
    virtual void PourInCup(){
        cout << "将茶水倒入杯中!" << endl;
    }
    //加入辅料
    virtual void PutSomething(){
        cout << "加入食盐!" << endl;
    }
};

//业务函数
void DoBussiness(AbstractDrinking* drink){
    drink->MakeDrink();
    delete drink;
}
void test(){
    DoBussiness(new Coffee);
    cout << "--------------" << endl;
    DoBussiness(new Tea);
}
```

### **4.8.5 纯虚函数和多继承**

多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。

绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，c++中没有接口的概念，但是可以通过纯虚函数实现接口。

接口类中只有函数原型定义，没有任何数据定义。

多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。

**注意:接口类（也称为抽象类）中除了析构函数外，其他声明都是纯虚函数（注意这里说法比较绝对，但这样做更加规范）。**

> 必要的补充说明：
>
> - 接口类通常包含**纯虚函数**，但并非只能包含纯虚函数。它还可以包含虚析构函数、普通成员函数、静态成员、常量、甚至默认实现等。
> - 接口类的核心目的是定义接口或契约，要求派生类实现某些功能，但它并不严格限制只含纯虚函数。
> - 构造函数也可以出现在接口类中。
> - 构造函数不可以是虚函数。
> - 析构函数可以是虚函数也可以是纯虚函数。

### **4.8.6 虚析构函数**

#### **4.8.6.1 虚析构函数作用**

虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

```cpp
class People{
public:
    People(){
        cout << "构造函数 People!" << endl;
    }
    virtual void showName() = 0;
    virtual ~People(){
        cout << "析构函数 People!" << endl;
    }
};

class Worker : public People{
public:
    Worker(){
        cout << "构造函数 Worker!" << endl;
        pName = new char[10];
    }
    virtual void showName(){
        cout << "打印子类的名字!" << endl;
    }
    ~Worker(){
        cout << "析构函数 Worker!" << endl;
        if (pName != NULL){
            delete pName;
        }
    }
private:
    char* pName;
};
/*构造函数 People!
构造函数 Worker!
析构函数 Worker!
析构函数 People!*/
```

> 这里基类析构函数不是虚函数，那么不会输出析构函数 Worker!，即不会析构派生类Worker。

#### **4.8.6.2 纯虚析构函数**

纯虚析构函数在c++中是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。

那么问题是：如果给虚析构函数提供函数体了，那怎么还能称作纯虚析构函数呢？

纯虚析构函数和非纯虚析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。

```cpp
//非纯虚析构函数
class A{
public:
    virtual ~A();//这里只是函数声明
};

A::~A(){}

//纯虚析构函数
class B{
public:
    virtual ~B() = 0;
};

void test(){
    A a; //A类不是抽象类，可以实例化对象
//    B b; //B类是抽象类，不可以实例化对象
}
```

如果类的目的不是为了实现多态，作为基类来使用，就不要声明虚析构函数，反之，则应该为类声明虚析构函数。

### **4.8.7 重写 重载 重定义**

- 重载，同一作用域的同名函数

1.同一个作用域

2.参数个数，参数顺序，参数类型不同

3.和函数返回值，没有关系

4.const也可以作为重载条件 //do(const Teacher& t){} do(Teacher& t)

- 重定义（隐藏）

1.有继承

2.子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）

- 重写（覆盖）

1.有继承

2.子类（派生类）重写父类（基类）的virtual函数

3.函数返回值，函数名字，函数参数，必须和基类中的虚函数一致

```cpp
class A{
public:
	//同一作用域下，func1函数重载
	void func1(){}
	void func1(int a){}
	void func1(int a,int b){}
	void func2(){}
	virtual void func3(){}
};

class B : public A{
public:
	//重定义基类的func2,隐藏了基类的func2方法
	void func2(){}
	//重写基类的func3函数，也可以覆盖基类func3
	virtual void func3(){}
};
```

### **4.8.8 指向类成员的指针**

#### **4.8.8.1 指向成员变量的指针**

- 定义格式

```
<数据类型> <类名>::*<指针名>
```

例如: `int A::*pPram;`

- 赋值/初始化

```
<数据类型> <类名>::*<指针名> = &<类名>::<非静态数据成员>
```

例如: `int A::*pParam = &A::param;`

- 解引用

```
<类对象名>.*<非静态数据成员指针>
<类对象指针>->*<非静态数据成员指针>
```

例如: `A a;`

```
a.*pParam;
a->*pParam;
class A{
public:
    A(int param){
        mParam = param;
    }
public:
    int mParam;
};

void test(){
    A a1(100);
    A* a2 = new A(200);
    int* p1 = &a1.mParam;
    int& p11=a1.mParam;
    p11=500;

    int A::*p2 = &A::mParam;

    cout << "&a1:" << &a1.mParam << endl;
    cout << "p1:" << p1 << endl;
    cout << "&p11:" << &p11 << endl;
    cout << "*p1:" << *p1 << endl;
    cout << "p11:" << p11 << endl;

    cout << "a1.*p2:" << a1.*p2 << endl;
    cout << "a2->*p2:" << a2->*p2 << endl;
}
/*&a1:0x1001ff93c
p1:0x1001ff93c
&p11:0x1001ff93c
*p1:500
p11:500
a1.*p2:500
a2->*p2:200*/
```

> 对象普通成员变量同普通变量一样可以被指针和引用操作。
>
> 这里的指向成员变量的指针相当于给整个类的一个成员变量（非静态）取了以*开头的别名。

#### **4.8.8.2 指向成员函数的指针**

- 定义格式

```
<返回类型> (<类名>::*<指针名>)（<参数列表>）
```

​        例如: `void (A::*pFunc)(int,int);`

- 赋值/初始化

```
<返回类型>（<类名>::*<指针名>）（<参数列表>） = &<类名>::<非静态数据函数>
```

例如: `void (A::pFunc)(int,int) = &A::func;`

- 解引用

```
（<类对象名>.*<非静态成员函数>）（<参数列表>）
（<类对象指针>->*<非静态成员函数>）（<参数列表>）
```

例如: `A a;`

```
(a.*pFunc)(10,20);
(a->*pFunc)(10,20);
class A{
public:
	int func(int a,int b){
		return a + b;
	}
};

void test(){
	A a1;
	A* a2 = new A;

	//初始化成员函数指针
	int(A::*pFunc)(int, int) = &A::func;
	//指针解引用
	cout << "(a1.*pFunc)(10,20):" << (a1.*pFunc)(10, 20) << endl;
	cout << "(a2->*pFunc)(10,20):" << (a2->*pFunc)(10, 20) << endl;
}
```

#### **4.8.8.3 指向静态成员的指针**

指向类静态数据成员的指针\ 指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。

class A{
public:
	static void dis(){
		cout << data << endl;
	}
	static int data;
};

int A::data = 100;

void test(){
	int *p = &A::data;
	cout << *p << endl;
	void(*pfunc)() = &A::dis;
	pfunc();
}

ps：参考：[c++讲义 第一部分.doc](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/c%2B%2B%E8%AE%B2%E4%B9%89%20%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.doc)或[c++讲义第一部分.pdf](https://blog-halo.oss-cn-guangzhou.aliyuncs.com/halo/2024/11/18/c%2B%2B%E8%AE%B2%E4%B9%89%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86.pdf)（黑马2017年C++视频）